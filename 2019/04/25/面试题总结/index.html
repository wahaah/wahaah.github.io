<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/timg1.jpg?v=6.7.0">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、总结前端习题1.原型对象与实例对象的区别： 2.数据类型简单数据类型：Boolean  number  null   undefined  string  引用类型：Object(包括Function Array  ,RegExp, Date) 内置对象：Date Array Math  Global等不可以实例化的 基本包装类型：String  Number  Boolean 宿主对象：为浏">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="http://yoursite.com/2019/04/25/面试题总结/index.html">
<meta property="og:site_name" content="studyingHouse">
<meta property="og:description" content="1、总结前端习题1.原型对象与实例对象的区别： 2.数据类型简单数据类型：Boolean  number  null   undefined  string  引用类型：Object(包括Function Array  ,RegExp, Date) 内置对象：Date Array Math  Global等不可以实例化的 基本包装类型：String  Number  Boolean 宿主对象：为浏">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="file:///C:/Users/赵雪玲/AppData/Local/Temp/ksohtml/wpsD315.tmp.jpg">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2012/327530/2012062914380085.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/blog/644616/201508/122056471456596.jpg">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png">
<meta property="og:image" content="file:///C:/Users/赵雪玲/AppData/Local/Temp/ksohtml/wpsD315.tmp.jpg">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109001005441-128129104.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109004129331-2122753353.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/1209205/201709/1209205-20170928000104559-1868896430.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817111910680-801527203.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817112043763-1535904519.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/861963/201603/861963-20160318180203631-843727359.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:updated_time" content="2019-04-25T09:42:55.008Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题总结">
<meta name="twitter:description" content="1、总结前端习题1.原型对象与实例对象的区别： 2.数据类型简单数据类型：Boolean  number  null   undefined  string  引用类型：Object(包括Function Array  ,RegExp, Date) 内置对象：Date Array Math  Global等不可以实例化的 基本包装类型：String  Number  Boolean 宿主对象：为浏">
<meta name="twitter:image" content="file:///C:/Users/赵雪玲/AppData/Local/Temp/ksohtml/wpsD315.tmp.jpg">






  <link rel="canonical" href="http://yoursite.com/2019/04/25/面试题总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试题总结 | studyingHouse</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/wahaah" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">studyingHouse</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">The harder you work,the more luck you have!</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/面试题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ling">
      <meta itemprop="description" content="little repository">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="studyingHouse">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试题总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-25 17:42:09 / 修改时间：17:42:55" itemprop="dateCreated datePublished" datetime="2019-04-25T17:42:09+08:00">2019-04-25</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1、总结前端习题"><a href="#1、总结前端习题" class="headerlink" title="1、总结前端习题"></a>1、总结前端习题</h2><h4 id="1-原型对象与实例对象的区别："><a href="#1-原型对象与实例对象的区别：" class="headerlink" title="1.原型对象与实例对象的区别："></a>1.原型对象与实例对象的区别：</h4><p><img src="file:///C:\Users\赵雪玲\AppData\Local\Temp\ksohtml\wpsD315.tmp.jpg" alt="img"></p>
<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p>简单数据类型：Boolean  number  null   undefined  string </p>
<p>引用类型：Object(包括Function Array  ,RegExp, Date)</p>
<p>内置对象：Date Array Math  Global等不可以实例化的</p>
<p>基本包装类型：String  Number  Boolean</p>
<p>宿主对象：为浏览器自带的 document,window 等</p>
<p>BOM对象:  window ,document , location ,history, navigation,screen</p>
<p>本地对象：为 array obj regexp 等可以 new 实例化</p>
<h4 id="3-嵌入html文档中的图像格式"><a href="#3-嵌入html文档中的图像格式" class="headerlink" title="3.嵌入html文档中的图像格式"></a>3.嵌入html文档中的图像格式</h4><p>可以是：.gif  .bmp .webp   .png  .jpg  .jpeg</p>
<p>.bmp清晰，但占内存很大</p>
<p>.webp         占内存小</p>
<h4 id="4-判断类型"><a href="#4-判断类型" class="headerlink" title="4.判断类型"></a>4.判断类型</h4><p>（1）typeof:          typeof  variable</p>
<p>​    typeof返回的类型：undefined  boolean  string  number  object对象 (null  function函数)</p>
<p>（2）instanceof:     variable instanceof  constructor</p>
<p>​    返回值：true/false</p>
<p>通常用typeof来判断数据类型，但再new String的情况下结果会是Object,所以要通过instanceof来判断</p>
<h4 id="5-jQuery-ajax支持哪些数据类型"><a href="#5-jQuery-ajax支持哪些数据类型" class="headerlink" title="5.jQuery ajax支持哪些数据类型"></a>5.jQuery ajax支持哪些数据类型</h4><p>xml json jsonp  html text script</p>
<h4 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6.正则表达式"></a>6.正则表达式</h4><p>若指定 g，则：每次调用 exec 都从上一个匹配之后查找新的匹配；match 则是返回所有的匹配。</p>
<p>参数 i 是指忽略大小写，注意仅是忽略大小写，并不忽略全半角。</p>
<p>（1）JavaScript有两种方式创建一个正则表达式：</p>
<p>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</p>
<p>（2）</p>
<p><code>\s</code>是匹配空格回车等</p>
<p>用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，</p>
<p><code>.</code>可以匹配任意字符</p>
<p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：</p>
<p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>
<p>要做更精确地匹配，可以用<code>[]</code>表示范围</p>
<p><code>A|B</code>可以匹配A或B</p>
<p><code>^</code>表示行的开头</p>
<p><code>$</code>表示行的结束</p>
<h4 id="7-CSS-的盒子模型有两种：IE-盒子模型、标准的-W3C-盒子模型模型"><a href="#7-CSS-的盒子模型有两种：IE-盒子模型、标准的-W3C-盒子模型模型" class="headerlink" title="7.CSS 的盒子模型有两种：IE 盒子模型、标准的 W3C 盒子模型模型"></a>7.CSS 的盒子模型有两种：IE 盒子模型、标准的 W3C 盒子模型模型</h4><p>ie盒子模型：内容宽度=content+padding+border的宽度</p>
<p>标准盒子模型：内容宽度=content的宽度</p>
<p>盒子的总宽度：左右margin+左右border+左右padding+width</p>
<h4 id="8-inline-block元素："><a href="#8-inline-block元素：" class="headerlink" title="8.inline-block元素："></a>8.inline-block元素：</h4><p>img button input textarea label</p>
<h4 id="9-无效值或空值："><a href="#9-无效值或空值：" class="headerlink" title="9.无效值或空值："></a>9.无效值或空值：</h4><p>null  false  undefined  “ “  NaN  0</p>
<h4 id="10-空元素"><a href="#10-空元素" class="headerlink" title="10.空元素"></a>10.空元素</h4><p>​    <code>&lt;hr&gt; &lt;img&gt;   &lt;input&gt; &lt;link&gt;  &lt;meta&gt;  &lt;br&gt;</code>   </p>
<p>​    不常见的</p>
<p>​    <code>&lt;base&gt;  &lt;col&gt; &lt;command&gt; &lt;embed&gt;  &lt;keygen&gt;  &lt;param&gt; &lt;area&gt;</code></p>
<h4 id="11、ajax"><a href="#11、ajax" class="headerlink" title="11、ajax"></a>11、ajax</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XmlHttpRequest()</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;url&quot;)</span><br><span class="line">xhr.send()</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123;</span><br><span class="line">        console.log()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var xhr = new XmlHttpRequest()</span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line">xhr.open(&quot;post&quot;,&quot;url&quot;)</span><br><span class="line">xhr.send(data)</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123;</span><br><span class="line">        console.log()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五大步骤</p>
<p>1.新建一个异步对象</p>
<p>var xhr = new XmlHttpRequest()</p>
<p>2.使用open方法设置和服务器的交互信息</p>
<p>xhr.open(“get”,”url/ff”+name) </p>
<p>//get方式可拼接</p>
<p>3.设置发送的数据，开始和服务器端交互,发送请求</p>
<p>xhr.send()</p>
<p>4.注册事件</p>
<p>xhr.onreadystatechange = function(){</p>
<p>5.更新界面</p>
<p>​    if(xhr.readystate==4&amp;&amp;xhr.state==200){<br>            console.log(xhr.reponseText)<br>    }</p>
<p>}</p>
<hr>
<p>1.新建一个异步对象</p>
<p>var xhr = new XmlHttpRequest()</p>
<p>xhr.setRequestHeader(“Content-type”：“application/x-www-form-urlencoded”)</p>
<p>2.使用open方法设置和服务器的交互信息</p>
<p>xhr.open(“post”,”url”) </p>
<p>3.设置发送的数据，开始和服务器端交互(post中可将数据发送至此)</p>
<p>xhr.send(“name=fox&amp;age=18”)</p>
<p>4.注册事件</p>
<p>xhr.onreadystatechange = function(){</p>
<p>5.更新界面</p>
<p>​    if(xhr.readystate==4&amp;&amp;xhr.state==200){<br>            console.log(xhr.reponseText)<br>    }</p>
<p>}</p>
<h4 id="12、ECMAScript包括两个不同类型的值："><a href="#12、ECMAScript包括两个不同类型的值：" class="headerlink" title="12、ECMAScript包括两个不同类型的值："></a>12、ECMAScript包括两个不同类型的值：</h4><p>基本数据类型和引用数据类型:</p>
<h5 id="1、常见的基本数据类型："><a href="#1、常见的基本数据类型：" class="headerlink" title="1、常见的基本数据类型："></a>1、常见的基本数据类型：</h5><p>　　Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line"></span><br><span class="line">　　var b = a;</span><br><span class="line"></span><br><span class="line">　　b = 20;</span><br><span class="line"></span><br><span class="line">　　console.log(a); // 10值</span><br></pre></td></tr></table></figure>
<p>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。</p>
<p>　　<strong>b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</strong></p>
<p>　　下图演示了这种基本数据类型赋值的过程：</p>
<p><img src="https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg" alt="img"></p>
<p><a href="https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg" target="_blank" rel="noopener">https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg</a></p>
<h5 id="2、引用类型数据："><a href="#2、引用类型数据：" class="headerlink" title="2、引用类型数据："></a>2、引用类型数据：</h5><p>　　<strong>也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。</strong></p>
<p>　　javascript的引用数据类型是保存在堆内存中的对象。</p>
<p>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p>
<p>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　var obj1 = new Object();</span><br><span class="line"></span><br><span class="line">　　var obj2 = obj1;</span><br><span class="line"></span><br><span class="line">　　obj2.name = &quot;我有名字了&quot;;</span><br><span class="line"></span><br><span class="line">　　console.log(obj1.name); // 我有名字了</span><br></pre></td></tr></table></figure>
<p>说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，</p>
<p>　　但是实际上他们共同指向了同一个堆内存对象。<strong>实际上改变的是堆内存对象。</strong></p>
<p>　　下面我们来演示这个引用数据类型赋值过程：</p>
<p><img src="https://pic002.cnblogs.com/images/2012/327530/2012062914380085.jpg" alt="img"></p>
<p><strong>4、总结区别</strong></p>
<p>　　<strong>a 声明变量时不同的内存分配：</strong>　</p>
<p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。</p>
<p>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</p>
<p>　　2）引用值：存储在堆（heap）中的对象，也就是说，<strong>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</strong></p>
<p>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。</p>
<p>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p>
<p>​      <strong>b 不同的内存分配机制也带来了不同的访问机制</strong></p>
<p>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的<strong>按引用访问</strong>。</p>
<p>　　2）而原始类型的值则是可以直接访问到的。</p>
<p>　　<strong>c 复制变量时的不同</strong></p>
<p>　　1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，<strong>此后这两个变量是完全独立的，他们只是拥有相同的value而已。</strong>也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。<strong>多了一个指针</strong></p>
<p>　　<strong>d 参数传递的不同（把实参复制给形参的过程）</strong></p>
<p>　　首先我们应该明确一点：ECMAScript中所有<strong>函数的参数</strong>都<strong>是按值来传递</strong>的。</p>
<p>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</p>
<p>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！</p>
<p>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p>
<h4 id="13、hasOwnProperty方法"><a href="#13、hasOwnProperty方法" class="headerlink" title="13、hasOwnProperty方法"></a>13、hasOwnProperty方法</h4><p>语法：obj.hasOwnProperty(prop)</p>
<p>所有继承了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a> 的对象都会继承到 <code>hasOwnProperty</code> 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener"><code>in</code></a> 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</p>
<p>使用for  in循环数组中的元素会枚举原型链上的所有属性，过滤这些属性的方式是使用hasOwnProperty函数</p>
<h4 id="14、slice"><a href="#14、slice" class="headerlink" title="14、slice()"></a>14、slice()</h4><p>slice() 方法可从已有的数组中返回选定的元素。</p>
<p>语法：arrayObject.slice(start,end)</p>
<p>参数：</p>
<table>
<thead>
<tr>
<th>start</th>
<th>必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</th>
</tr>
</thead>
<tbody>
<tr>
<td>end</td>
<td>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody>
</table>
<p>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>说明：请注意，该方法并不会修改数组，而是返回一个子数组。</p>
<p>提示和注释：</p>
<p>注释：您可使用负值从数组的尾部选取元素。</p>
<p>注释：如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p>
<h4 id="15、静态成员和实例成员的区别"><a href="#15、静态成员和实例成员的区别" class="headerlink" title="15、静态成员和实例成员的区别"></a>15、静态成员和实例成员的区别</h4><p>静态成员：要通过构造函数来调用  Hero.version = 1.0</p>
<p>实例成员：与对象相关的成员，使用对象的方式来调用（  hero.attack()   ）</p>
<h4 id="16-js中的方法"><a href="#16-js中的方法" class="headerlink" title="16.js中的方法"></a>16.js中的方法</h4><p>push  splice sort会改变原有的数组</p>
<p>slice不会改变原有数组，只会返回一个新的数组</p>
<h5 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1.charAt()"></a>1.charAt()</h5><p>方法可返回指定位置的字符。</p>
<p>第一个字符位置为 0, 第二个字符位置为 1,以此类推.</p>
<h5 id="2-join"><a href="#2-join" class="headerlink" title="2.join()"></a>2.join()</h5><p>join() 方法用于把数组中的所有元素转换一个字符串。</p>
<p>元素是通过指定的分隔符进行分隔的。</p>
<p>语法：array.join(<em>separator</em>)</p>
<p>separator可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</p>
<h5 id="3-split"><a href="#3-split" class="headerlink" title="3.split()"></a>3.split()</h5><p>split() 方法用于把一个字符串分割成字符串数组。</p>
<p><strong>提示：</strong> 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</p>
<p><strong>注意：</strong> split() 方法不改变原始字符串。</p>
<p>语法：<em>string</em>.split(<em>separator</em>,<em>limit</em>)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>separator</em></td>
<td>可选。字符串或正则表达式，从该参数指定的地方分割 string Object。</td>
</tr>
<tr>
<td><em>limit</em></td>
<td>可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</td>
</tr>
</tbody>
</table>
<h5 id="4、splice"><a href="#4、splice" class="headerlink" title="4、splice()"></a>4、splice()</h5><p>方法用于添加或删除数组中的元素。</p>
<p><strong>注意：</strong>这种方法会改变原始数组。</p>
<p>返回值: 如果仅删除一个元素，则返回一个元素的数组。 如果未删除任何元素，则返回空数组。</p>
<p>语法：<em>array</em>.splice(<em>index</em>,<em>howmany</em>,<em>item1</em>,…..,<em>itemX</em>)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>index</em></td>
<td>必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td>
</tr>
<tr>
<td><em>howmany</em></td>
<td>必需。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td>
</tr>
<tr>
<td><em>item1</em>, …, <em>itemX</em></td>
<td>可选。要添加到数组的新元素</td>
</tr>
</tbody>
</table>
<p>注意：第三个参数一般不写，若写第三个参数时，则从删除元素位置开始，插入从第三个参数开始若干（一个或多个）的参数</p>
<h5 id="5、concat"><a href="#5、concat" class="headerlink" title="5、concat()"></a>5、concat()</h5><p>concat() 方法用于连接两个或多个字符串。</p>
<p>该方法没有改变原有字符串，但是会返回连接两个或多个字符串新字符串。</p>
<p>语法：<em>string</em>.concat(<em>string1</em>, <em>string2</em>, …, <em>stringX</em>)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>string1</em>, <em>string2</em>, …, <em>stringX</em></td>
<td>必需。将被连接为一个字符串的一个或多个字符串对象。</td>
</tr>
</tbody>
</table>
<h5 id="6、substring"><a href="#6、substring" class="headerlink" title="6、substring()"></a>6、substring()</h5><p>方法用于提取字符串中介于两个指定下标之间的字符。</p>
<p>substring() 方法返回的子串包括 <em>开始</em> 处的字符，但不包括 <em>结束</em> 处的字符。</p>
<p>语法：string.substring(from, to)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>必需。一个非负的整数，规定要提取的子串的第一个字符在 string Object 中的位置。</td>
</tr>
<tr>
<td>to</td>
<td>可选。一个非负的整数，比要提取的子串的最后一个字符在 string Object 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</td>
</tr>
</tbody>
</table>
<h5 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h5><h4 id="17、IE流和DOM流的区别"><a href="#17、IE流和DOM流的区别" class="headerlink" title="17、IE流和DOM流的区别"></a>17、IE流和DOM流的区别</h4><p>ie流：冒泡阶段</p>
<p>dom流：冒泡阶段+捕获阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行顺序不同</span><br><span class="line"></span><br><span class="line">事件加不加on</span><br><span class="line"></span><br><span class="line">参数不同</span><br><span class="line"></span><br><span class="line">this指向不同</span><br></pre></td></tr></table></figure>
<h4 id="18、random"><a href="#18、random" class="headerlink" title="18、random()"></a>18、random()</h4><p> 方法可返回介于 0 ~ 1 之间的一个随机数。</p>
<p>这个数可能为0，但会小于1。</p>
<h4 id="19、document-forms-length和document-forms-elements-length的区别"><a href="#19、document-forms-length和document-forms-elements-length的区别" class="headerlink" title="19、document.forms.length和document.forms.elements.length的区别"></a>19、document.forms.length和document.forms.elements.length的区别</h4><p>document.forms.length：是判断dom树中有多少个form元素，或者说判断其长度</p>
<p>document.forms.elements.length：判断此form表单的长度</p>
<h4 id="20、JavaScript-有一些保留字，不能用作标识符："><a href="#20、JavaScript-有一些保留字，不能用作标识符：" class="headerlink" title="20、JavaScript 有一些保留字，不能用作标识符："></a>20、JavaScript 有一些保留字，不能用作标识符：</h4><p>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p>
<h4 id="21、判断类型"><a href="#21、判断类型" class="headerlink" title="21、判断类型"></a>21、判断类型</h4><p>1.操作符 </p>
<p>（1）typeof操作符 </p>
<p>格式：result=typeof variable </p>
<p>返回值： </p>
<p>undefined 值未定义 </p>
<p>boolean 布尔值 </p>
<p>string 字符串 </p>
<p>number 数值 </p>
<p>object 对象、null </p>
<p>function 函数 </p>
<p>（2）instanceof操作符 </p>
<p>格式：result=variable instanceof constructor </p>
<p>返回值： </p>
<p>true </p>
<p>false </p>
<ol>
<li>方法 </li>
</ol>
<p>String.prototype.isString=function(str){ </p>
<p>return ((str instanceof String) || (typeof str).toLowerCase() == ‘string’); </p>
<p>} </p>
<p>3.原理 </p>
<p>var str1=new String(‘str1’); </p>
<p>var str2=’str2’; </p>
<p>console.log(typeof str1);//object </p>
<p>console.log(typeof str2);//string </p>
<p>console.log(str1 instanceof String);//true </p>
<p>console.log(str2 instanceof String);//false</p>
<h4 id="22、BOM浏览器对象模型"><a href="#22、BOM浏览器对象模型" class="headerlink" title="22、BOM浏览器对象模型"></a>22、BOM浏览器对象模型</h4><p>访问和操作浏览器窗口的模型称为浏览器对象模型BOM（Browser Object Model）。</p>
<p><a href="https://images0.cnblogs.com/blog/644616/201508/122056471456596.jpg" target="_blank" rel="noopener">https://images0.cnblogs.com/blog/644616/201508/122056471456596.jpg</a></p>
<p><img src="https://images0.cnblogs.com/blog/644616/201508/122056471456596.jpg" alt="05572017068"></p>
<p>核心是window对象；</p>
<p>以下有特殊双重身份：</p>
<p><strong>window对象</strong>既是ECMAScript规范中的Global对象，也是BOM中的顶级对象；</p>
<p><strong>document对象</strong>既是BOM顶级对象的一个属性，也是DOM模型中的顶级对象</p>
<p><strong>location对象</strong>既是window对象的属性，同时也是document对象的属性。</p>
<h2 id="2、面试题"><a href="#2、面试题" class="headerlink" title="2、面试题"></a>2、面试题</h2><h3 id="1、apply、call、bind的区别"><a href="#1、apply、call、bind的区别" class="headerlink" title="1、apply、call、bind的区别"></a>1、apply、call、bind的区别</h3><p>（1）call、apply、bind的作用是改变函数运行时this的指向</p>
<p>（2）call、apply相同之处在于，<code>第一个参数都是要绑定的上下文，后面的参数是要传递给调用该方法的函数的。</code><br>不同之处在于，call 方法传递给调用函数的参数是逐个列出的，而 apply 则是要写在数组中。</p>
<p>（3）核心要点： 可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 Object 没有某个方法，但是呢，其它的对象有，我们可以借助 call 或 apply 用其它对象的方法来操作</p>
<h5 id="1-apply-例子："><a href="#1-apply-例子：" class="headerlink" title="(1)apply 例子："></a>(1)apply 例子：</h5><p>接受两个参数，一是作用域，二是参数（可以是数组也可以是arguments对象）。</p>
<p>var People = {<br>  sayHello: function(arg1) {<br>    console.log(‘你好，’ + this.name + ‘，’ + arg1)<br>  }<br>}<br>var me = {<br>  name: ‘Neveryu’<br>}</p>
<p>People.sayHello.apply(me, [‘很高兴见到你’])  // 你好，Neveryu，很高兴见到你</p>
<h5 id="2-call-例子："><a href="#2-call-例子：" class="headerlink" title="(2)call 例子："></a>(2)call 例子：</h5><p>call()必须明确的传入每一个参数。</p>
<p>var People = {<br>  sayHello: function(arg1) {<br>    console.log(‘你好，’ + this.name + ‘，’ + arg1)<br>  }<br>}<br>var me = {<br>  name: ‘Neveryu’<br>}</p>
<p>People.sayHello.call(me, ‘很高兴见到你’)  // 你好，Neveryu，很高兴见到你</p>
<h5 id="3-bind-例子："><a href="#3-bind-例子：" class="headerlink" title="(3)bind 例子："></a>(3)bind 例子：</h5><p>var People = {<br>  sayHello: function(arg1) {<br>    console.log(‘你好，’ + this.name + ‘，’ + arg1)<br>  }<br>}<br>var me = {<br>  name: ‘Neveryu’<br>}<br>People.sayHello.bind(me, ‘很高兴见到你’)()  // 你好，Neveryu，很高兴见到你<br>People.sayHello.bind(me, [‘很高兴见到你’])()  // 你好，Neveryu，很高兴见到你</p>
<p>bind 方法传递给调用函数的参数可以逐个列出，也可以写在数组中。bind 方法与 call、apply 最大的不同就是前者 返回一个绑定上下文的函数，而<code>后者是直接执行了函数。</code></p>
<p>bind 方法还可以这样写 <code>fn.bind(obj, arg1)(arg2)</code> 。</p>
<p>总结 bind 的用法：该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 bind 方法的第一个参数作为 this，传入 bind 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<h3 id="2、闭包（closure）"><a href="#2、闭包（closure）" class="headerlink" title="2、闭包（closure）"></a>2、闭包（closure）</h3><h4 id="一、要理解闭包，首先必须理解Javascript特殊的变量作用域。"><a href="#一、要理解闭包，首先必须理解Javascript特殊的变量作用域。" class="headerlink" title="一、要理解闭包，首先必须理解Javascript特殊的变量作用域。"></a>一、要理解闭包，首先必须理解Javascript特殊的变量作用域。</h4><p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var n=999;</span><br><span class="line"></span><br><span class="line">　　function f1()&#123;</span><br><span class="line">　　　　alert(n);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1(); // 999</span><br></pre></td></tr></table></figure>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">　　　　var n=999;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　alert(n); // error</span><br></pre></td></tr></table></figure>
<p>函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　function f1()&#123;</span><br><span class="line">　　　　n=999;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　f1();</span><br><span class="line"></span><br><span class="line">　　alert(n); // 999</span><br></pre></td></tr></table></figure>
<h4 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h4><p>正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<p>Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n=999;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); // 999</span><br></pre></td></tr></table></figure>
<h4 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h4><p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>用途：</p>
<p>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。（一直在调用，延展变量的生命周期）</p>
<p>使用闭包的注意点</p>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。  &lt;内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，不能被垃圾回收机制回收，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&gt;   解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line"></span><br><span class="line">　　　　var n=999;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=function()&#123;n+=1&#125;</span><br><span class="line"></span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　return f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　var result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); // 999</span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); // 1000</span><br></pre></td></tr></table></figure>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">代码片段1：</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　console.log(object.getNameFunc()());   </span><br><span class="line">　　</span><br><span class="line">　　</span><br><span class="line">　代码片段2：</span><br><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　console.log(object.getNameFunc()());//My Object</span><br></pre></td></tr></table></figure>
<h3 id="3、深拷贝、浅拷贝"><a href="#3、深拷贝、浅拷贝" class="headerlink" title="3、深拷贝、浅拷贝"></a>3、深拷贝、浅拷贝</h3><h4 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h4><p>（通俗讲，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。）</p>
<p>要了解其本质区别，就需要了解堆和栈，值与引用的概念及区别</p>
<h4 id="1-堆（stack）和栈（heap）"><a href="#1-堆（stack）和栈（heap）" class="headerlink" title="1.堆（stack）和栈（heap）"></a>1.堆（stack）和栈（heap）</h4><p>stack为自动分配的内存空间，它由系统自动释放；</p>
<p>heap则是动态分配的内存，大小不定也不会自动释放。</p>
<h4 id="2-值与引用"><a href="#2-值与引用" class="headerlink" title="2.值与引用"></a>2.值与引用</h4><p>js中有基本数据类型和引用类型；</p>
<p>基本数据类型：number  null  string  undefined boolean</p>
<p>引用类型（复杂数据类型）：对象  数组  函数</p>
<p>基本数据类型的变量和值都是存放在栈中，声明之后会分配一块内存区域，基本数据类型之间的赋值是直接把栈内存中存的值赋值给变量（传值）</p>
<p>引用类型的变量存在栈中，但值是存在堆中，实际上栈存放的是指向堆中的地址，也叫引用，引用类型直接的赋值实质是把引用赋值给一个变量（传址），所以其指向的堆内存中的值是一样的。</p>
<h4 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3.深拷贝和浅拷贝"></a>3.深拷贝和浅拷贝</h4><p>深拷贝和浅拷贝的使用场景是在<strong>复杂对象</strong>里，即对象的属性还是对象，</p>
<h5 id="（1）浅拷贝："><a href="#（1）浅拷贝：" class="headerlink" title="（1）浅拷贝："></a>（1）浅拷贝：</h5><p>是指只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a:1, arr: [2,3] &#125;;</span><br><span class="line">var shallowObj = shallowCopy(obj);</span><br><span class="line"></span><br><span class="line">function shallowCopy(src) &#123;</span><br><span class="line">  var dst = &#123;&#125;;</span><br><span class="line">  for (var prop in src) &#123;</span><br><span class="line">    if (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当一个对象属性的引用值改变时将导致另一个也改变</span><br><span class="line">shallowObj.arr[1] = 5;</span><br><span class="line">obj.arr[1]   // = 5</span><br><span class="line">//当改变了新数组中的元素，此时旧数组中的值也发生了改变,两者指向同一内存地址</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a=[0,1,2,3,4],</span><br><span class="line">    b=a;</span><br><span class="line">console.log(a===b);</span><br><span class="line">a[0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><a href="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png</a></p>
<p><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124114023703-1953539844.png" alt="img"></p>
<h5 id="（2）深拷贝"><a href="#（2）深拷贝" class="headerlink" title="（2）深拷贝"></a>（2）深拷贝</h5><p>是指复制对象的所有层级，实现方法,</p>
<h6 id="1-gt-实现深拷贝，这里可以递归递归去复制所有层级属性。"><a href="#1-gt-实现深拷贝，这里可以递归递归去复制所有层级属性。" class="headerlink" title="1 &gt;   实现深拷贝，这里可以递归递归去复制所有层级属性。"></a>1 &gt;   实现深拷贝，这里可以递归递归去复制所有层级属性。</h6><p><code>深拷贝，是拷贝对象各个层级的属性</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let objClone = Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    if(obj &amp;&amp; typeof obj===&quot;object&quot;)&#123;</span><br><span class="line">        for(key in obj)&#123;</span><br><span class="line">            if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">                if(obj[key]&amp;&amp;typeof obj[key] ===&quot;object&quot;)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //如果不是，简单复制</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return objClone;</span><br><span class="line">&#125;    </span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br><span class="line">结果：</span><br><span class="line">[ 2, 2, 3, 4 ] [ 1, 2, 3, 4 ]</span><br></pre></td></tr></table></figure>
<h6 id="2-gt-还可以借用JSON对象的parse和stringify"><a href="#2-gt-还可以借用JSON对象的parse和stringify" class="headerlink" title="2&gt;   还可以借用JSON对象的parse和stringify"></a>2&gt;   还可以借用JSON对象的parse和stringify</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj),</span><br><span class="line">        objClone = JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;    </span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>[ 1, 1, [ 1, 3 ], 4 ]</p>
<p>[ 0, 1, [ 2, 3 ], 4 ]</p>
<p>说明：JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储</p>
<h6 id="3-gt-还可以借用JQ的extend方法。"><a href="#3-gt-还可以借用JQ的extend方法。" class="headerlink" title="3&gt;    还可以借用JQ的extend方法。"></a>3&gt;    还可以借用JQ的extend方法。</h6><p><strong>$.extend( [deep ], target, object1 [, objectN ] )</strong></p>
<p><strong>deep</strong>表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p>
<p><strong>target</strong> <strong>Object</strong>类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p><strong>object1  objectN</strong>可选。 Object类型 第一个以及第N个被合并的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=$.extend(true,[],a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
<p>结果 ：</p>
<p><a href="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png</a></p>
<p><img src="https://images2018.cnblogs.com/blog/1213309/201711/1213309-20171124154610578-1742013996.png" alt="img"></p>
<p>效果与上面方法一样，只是需要依赖JQ库。</p>
<p>注意：</p>
<p>—-以下操作并不是深拷贝，它只是基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当let a=1;</span><br><span class="line"></span><br><span class="line">当你b=a复制时，栈内存会新开辟一个内存</span><br><span class="line"></span><br><span class="line">此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据</span><br></pre></td></tr></table></figure>
<p>—–使用slice实现的也不是深拷贝，它不完全复制所有层级属性</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.当数组是一维数组时，并没有错误（虽然结果正确，但不算深拷贝）</span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=a.slice();</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br><span class="line">结果：</span><br><span class="line">[ 2, 2, 3, 4 ] [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">2.当数组为多层展现时</span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">b=a.slice();</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br><span class="line">结果：</span><br><span class="line">[ 1, 1, [ 1, 3 ], 4 ] </span><br><span class="line">[ 0, 1, [ 1, 3 ], 4 ]</span><br><span class="line">注意：</span><br><span class="line">	对比结果发现拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。</span><br><span class="line">	第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝</span><br></pre></td></tr></table></figure>
<h3 id="4，es6语法："><a href="#4，es6语法：" class="headerlink" title="4，es6语法："></a>4，es6语法：</h3><p>ES6官方文档：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p>
<ol>
<li>Object.assign  和  Object.keys的区别</li>
</ol>
<h3 id="5、原型链"><a href="#5、原型链" class="headerlink" title="5、原型链"></a>5、原型链</h3><p><img src="file:///C:\Users\赵雪玲\AppData\Local\Temp\ksohtml\wpsD315.tmp.jpg" alt="img"></p>
<p>s1. <strong>_  <em>proto</em></strong> _   :   实例对象的属性</p>
<p>prototype  ：是构造函数的属性</p>
<p>constructor : 是原型的属性</p>
<p>总结：当调用对象的属性或者方法的时候，先去找对象本身的属性/方法，如果对象没有该属性或者方法，此时去调用原型中的属性/方法。</p>
<p>若对象本身和原型中都没有该属性/方法，此时会报错</p>
<p>若访问一个不存在的属性，本身和原型链都没有，则返回undefined</p>
<p>若访问一个不存在的方法，原型链和本身都没有时则会报错</p>
<h3 id="6、一个数组如何排序"><a href="#6、一个数组如何排序" class="headerlink" title="6、一个数组如何排序"></a>6、一个数组如何排序</h3><p>要求：将数组中的name属性中的值，按照a-z的顺序进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">    &#123;name:&quot;jack&quot;,age:20&#125;,</span><br><span class="line">    &#123;name:&quot;juunk&quot;,age:20&#125;,</span><br><span class="line">    &#123;name:&quot;tony&quot;,age:20&#125;,</span><br><span class="line">    &#123;name:&quot;linda&quot;,age:20&#125;,</span><br><span class="line">    &#123;name:&quot;darlin&quot;,age:20&#125;</span><br><span class="line">]</span><br><span class="line">let newArr = arr.sort(function(a,b)&#123;</span><br><span class="line">    return a.name.charCodeAt() - b.name.charCodeAt()</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newArr);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[ &#123; name: &apos;darlin&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;jack&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;juunk&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;linda&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;tony&apos;, age: 20 &#125; ]</span><br><span class="line">  </span><br><span class="line">拓展：</span><br><span class="line">	charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。</span><br><span class="line">	方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。</span><br></pre></td></tr></table></figure>
<p>1.语法：stringObject.charCodeAt(index)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。表示字符串中某个位置的数字，即字符在字符串中的下标。</td>
</tr>
</tbody>
</table>
<p>注释：字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN。</p>
<hr>
<p>2.sort() 方法用于对数组的元素进行排序。</p>
<p>语法：arrayObject.sort(sortby)</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>sortby</em></td>
<td>可选。规定排序顺序。必须是函数。</td>
</tr>
</tbody>
</table>
<p>返回值：对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p>
<h3 id="7解构"><a href="#7解构" class="headerlink" title="7解构"></a>7解构</h3><p>是一种特殊格式访问数组和对象里面数据的方法</p>
<p>三种</p>
<p>作用（交换变量，赋值数组）concat   …不定参数</p>
<p>解构的原理是：从一个对象一次性解析出多个属性给不同变量，比如数组中解析出元素，从map/set中解析出数据等。</p>
<p>任何解构都有两个部分<br>1 解构源： 等号右边是要解构的对象。<br>2 解构目标：等号左边是要解构的对象。</p>
<h4 id="1-对象解构（解构源）"><a href="#1-对象解构（解构源）" class="headerlink" title="(1)对象解构（解构源）"></a>(1)对象解构（解构源）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    accessory: &apos;horn&apos;,</span><br><span class="line">    animal: &apos;horse&apos;,</span><br><span class="line">    color: &apos;purple&apos;,</span><br><span class="line">    hairType:&apos;curly&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始写法：</span><br><span class="line">function buildAnimal(animalData)&#123;</span><br><span class="line">    let accessory = animalData.accessory,</span><br><span class="line">        animal = animalData.animal,</span><br><span class="line">        color = animalData.color,</span><br><span class="line">        hairType = animalData.hairType;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">使用解构</span><br><span class="line">function buildAnimal(animalData)&#123;</span><br><span class="line">    let &#123;accessory, animal, color, hairType&#125; = animalData;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">animalData的对象属性给到变量:accessory, animal, color, hairType</span><br><span class="line">console.log(accessory);//horn</span><br><span class="line">console.log(animal); //horse</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">多层嵌套的对象怎么解构</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &apos;Maya&apos;,</span><br><span class="line">    age: 30,</span><br><span class="line">    phone: &apos;123&apos;,</span><br><span class="line">    address:&#123;</span><br><span class="line">        zipcode: 1234,</span><br><span class="line">        street: &apos;rainbow&apos;,</span><br><span class="line">        number: 42</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let &#123;address: &#123;zipcode, street, number&#125;&#125; = person;</span><br><span class="line">console.log(zipcode, street, number); //1234 rainbow 42</span><br><span class="line">或者</span><br><span class="line">let &#123;zipcode, street, number&#125; = person.address;</span><br><span class="line">console.log(zipcode, street, number); //1234 rainbow 42</span><br><span class="line"></span><br><span class="line">———————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">可能有人说我们需要，我们的变量名需要和属性名一样。实际上不需要。我们可以重新修改它的名字：比如</span><br><span class="line"></span><br><span class="line">let &#123;name: fullName&#125; = person;</span><br><span class="line">console.log(fullName); //Maya</span><br><span class="line">console.log(name); //ReferenceError: name is not defined.</span><br></pre></td></tr></table></figure>
<h4 id="2-解构数组"><a href="#2-解构数组" class="headerlink" title="(2)解构数组"></a>(2)解构数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们定义这样一个数组：</span><br><span class="line"></span><br><span class="line">var arr = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];</span><br><span class="line"></span><br><span class="line">var [first, second] = arr; //解构开始的两个元素</span><br><span class="line">var [,,third, four] = arr; //解构最后的两个元素 【行2】</span><br><span class="line">//如果不要解构某一个元素，直接逗号隔开就行了，参考:【行2】。要注意的是逗号的位置和数量</span><br><span class="line">var [one, two, three, four] = arr //解构所有元素</span><br><span class="line">_____________________________________________________________________________________</span><br><span class="line">解构嵌套数组：</span><br><span class="line">var arr2 = [[&apos;one&apos;, &apos;two&apos;], &apos;three&apos;, &apos;four&apos;];</span><br><span class="line">var [[one, two]] = arr2; //one = &apos;one&apos;, two = &apos;two&apos;</span><br><span class="line">——————————————————————————————————————————————————————————————————————————</span><br><span class="line">解构可遍历的对象：比如Map，Set，字符串等</span><br><span class="line">var [a, b] = new Set([1,2]); //a = 1, b = 2;</span><br><span class="line">var [a, b] = new Map([[1,2], [2,3]]); //a= [1,2], b = [2,3]</span><br><span class="line">var [x, y] = &quot;xyz&quot;; //x = &quot;x&quot;, y = &quot;y&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="(3)解构赋值"></a>(3)解构赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">多个变量的声明和初始化：</span><br><span class="line">let a, b, c, d;</span><br><span class="line">a = 2;</span><br><span class="line">b = 3;</span><br><span class="line">c = &#123; id: 4 &#125;;</span><br><span class="line">d = 5;</span><br><span class="line">//Or: let a = 2, b = 3, c = &#123; id: 4 &#125;, d = 5;</span><br><span class="line"></span><br><span class="line">解构赋值的话，我们可以这么写：</span><br><span class="line"></span><br><span class="line">let a, b, c, d;</span><br><span class="line">[a, b, c, d] = [2, 3, &#123; id: 4 &#125;, 5];</span><br><span class="line">//Or: let [a, b, c, d] = [2, 3, &#123; id: 4 &#125;, 5];</span><br></pre></td></tr></table></figure>
<h4 id="4-解构带上默认值"><a href="#4-解构带上默认值" class="headerlink" title="(4)解构带上默认值"></a>(4)解构带上默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果我们要解构的对象的属性没有值，甚至属性不存在。这个时候，我们需要一个默认值： </span><br><span class="line">通常我们可能会这么写：</span><br><span class="line">let name = person.name || &quot;default name&quot;; // and so on</span><br><span class="line"></span><br><span class="line">在解构里面，我们可以这么写</span><br><span class="line">let &#123;name = &quot;default name&quot;&#125; = obj;</span><br><span class="line">如果属性不存在，name 会被赋值一个默认的值。 </span><br><span class="line">或者：</span><br><span class="line">let &#123;name: myFullName = &quot;default name&quot;&#125; = obj;</span><br></pre></td></tr></table></figure>
<h4 id="5-多参数：-…操作符"><a href="#5-多参数：-…操作符" class="headerlink" title="(5)多参数： …操作符"></a>(5)多参数： …操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">比方说我们有一个数组，我们想要数组的第一个元素，剩余的元素用作其他用途。 </span><br><span class="line">一般我们会这么写：</span><br><span class="line"></span><br><span class="line">let first = arr[0],</span><br><span class="line">    rest = arr.slice(1);</span><br><span class="line"></span><br><span class="line">ES6解构我们可以这么写：</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = arr;</span><br><span class="line">console.log(first);// &quot;one&quot;</span><br><span class="line">console.log(rest); //[&quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span><br><span class="line"></span><br><span class="line">注意：…操作符只能放到最后。</span><br><span class="line">let [...rest, last] = arr;</span><br><span class="line">//SyntaxError: Rest element must be last element</span><br></pre></td></tr></table></figure>
<h4 id="6-交换"><a href="#6-交换" class="headerlink" title="(6)交换"></a>(6)交换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function swap(arr, i, j)&#123;</span><br><span class="line">    let temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">有了解构以后，我们可以这么写：</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j)&#123;</span><br><span class="line">   [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构在函数中的好处"><a href="#解构在函数中的好处" class="headerlink" title="解构在函数中的好处"></a>解构在函数中的好处</h4><p>在上面的例子中，我们是这么做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function buildAnimal(animalData)&#123;</span><br><span class="line">    let &#123;accessory, animal, color, hairType&#125; = animalData;</span><br><span class="line">    console.log(`I&apos;m a $&#123;color&#125; $&#123;animal&#125; with $&#123;accessory&#125; and $&#123;hairType&#125; hair`&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，我们希望直接从参数列表里解构出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function buildAnimal(&#123;accessory, animal, color, hairType&#125;&#125;&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以定义默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function buildAnimal(&#123;accessory = &quot;&quot;, animal = &quot;cat&quot;, color = &apos;rainbow&apos;, hairType = &apos;straight&apos;&#125;)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>调用的方式这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildAnimal(&#123;accessory = &quot;horn&quot;, animal = &quot;horse&quot;, color = &apos;purple&apos;, hairType = &apos;curly&apos;&#125;&#125;;</span><br><span class="line">//I&apos;m a purple horse with a horn and curly hair.</span><br></pre></td></tr></table></figure>
<p>注意一点：如果我们要默认参数，我们需要传递一个对象进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildAnimal(&#123;&#125;); //Works</span><br><span class="line">buildAnimal(); //Not working.</span><br></pre></td></tr></table></figure>
<p>我们能不传递一个空对象吗？可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function buildAnimal(&#123;accessory = &quot;&quot;, animal = &quot;cat&quot;, color = &apos;rainbow&apos;, hairType = &apos;straight&apos;&#125; = &#123;&#125;)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>我们给我们的参数一个默认的值：{}</p>
<p>数组也是类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum([a = 0, b = 0, c = 0]=[]) &#123; return a + b + c;&#125;</span><br><span class="line">console.log(sum([1, 2, 3])); //6</span><br><span class="line">console.log(sum()); //0</span><br></pre></td></tr></table></figure>
<h4 id="解构不好的地方"><a href="#解构不好的地方" class="headerlink" title="解构不好的地方"></a>解构不好的地方</h4><p>1 我们不能解构，如果没有采用声明的语法，或者（）包起来<br>因为解构是以{}开头，而{}在JavaScript中当做一个块，而不是对象常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a, b;</span><br><span class="line">&#123;a, b&#125; = &#123;a: 1, b: 2&#125;; //Error!!!</span><br><span class="line">(&#123;a,b&#125;) = &#123;a: 1, b: 2&#125;; //Error!!</span><br><span class="line">(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;); //OK1234</span><br></pre></td></tr></table></figure>
<p>2 嵌套对象的属性必须存在否则会解构失败</p>
<h3 id="8继承"><a href="#8继承" class="headerlink" title="8继承"></a>8继承</h3><p>1.es6中的方法</p>
<p>​    extend(fa,son)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class继承</span><br><span class="line">class是ES6新增的，继承通过extends实现</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    age() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    obj() &#123;</span><br><span class="line">        console.log(&apos;hello world&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class fn extends Foo &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    age() &#123;</span><br><span class="line">        console.log(`子类调用$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new fn(&apos;zhangsan&apos;);</span><br><span class="line">a.age();</span><br><span class="line">a.obj();</span><br></pre></td></tr></table></figure>
<p>2.原型继承（也叫类式继承）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每创建一个函数，该函数就会自动带有一个 prototype 属性。该属性是个指针，指向了一个对象，我们称之为 原型对象</span><br><span class="line"></span><br><span class="line">原型对象上默认有一个属性 constructor，该属性也是一个指针，指向其相关联的构造函数。</span><br><span class="line"></span><br><span class="line">通过调用构造函数产生的实例，都有一个内部属性，指向了原型对象。所以实例能够访问原型对象上的所有属性和方法。</span><br><span class="line">每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。通俗点说就是，实例通过内部指针可以访问到原型对象，原型对象通过constructor指针，又可以找到构造函数。</span><br></pre></td></tr></table></figure>
<p>继承：类型和类型之间的关系</p>
<p>继承目的： 把子类型中共同的成员提取到父类型中，代码重用</p>
<p>// 原型继承缺点： 无法设置构造函数的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      // 父类型</span><br><span class="line">      function Person() &#123;</span><br><span class="line">          this.name = &quot;可可&quot;;</span><br><span class="line">          this.sex = &quot;男&quot;;</span><br><span class="line">          this.age = &quot;36&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      // 子类型</span><br><span class="line">      function Student() &#123;</span><br><span class="line">          this.score = 50;</span><br><span class="line">      &#125;</span><br><span class="line">      // 要用此方式，如果用 Student.prototype=Person.prototype会出现内存上</span><br><span class="line">      // 指向同一地方，任何对象修改都会改变其中的内容</span><br><span class="line">      Student.prototype = new Person();</span><br><span class="line">      // 当设置prototype等于一个新的对象时，必须改变constructor的指向</span><br><span class="line">      // 改为所指的构造函数</span><br><span class="line">      Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">      // 创建对象</span><br><span class="line">      var stu = new Student();</span><br><span class="line">      console.log(stu.constructor);</span><br><span class="line">      // 此时构造函数指向Student</span><br><span class="line">      console.dir(stu);</span><br><span class="line">      console.log(stu.score);</span><br></pre></td></tr></table></figure>
<p>3.借用构造函数继承</p>
<p>在子类的构造函数中，通过 apply ( ) 或 call ( )的形式，调用父类构造函数，以实现继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        function person(name,age,sex)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.sex = sex;</span><br><span class="line">            // 借用构造函数，若将方法写在原型对象中，借用构造函数无法获取到方法</span><br><span class="line">            // 写到构造函数里面则可以获取继承到,但会造成代码重名，所以要解决将方法写在原型对象中，又要能通过借用构造函数可以访问到</span><br><span class="line">            // this.sayhi=function()&#123;</span><br><span class="line">            //     console.log(&quot;ffff&quot;);</span><br><span class="line">                </span><br><span class="line">            // &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        person.prototype.sayhi=function()&#123;</span><br><span class="line">            console.log(s1.name);</span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">        function student (name,age,sex,score)&#123;</span><br><span class="line">            this.score = score;</span><br><span class="line">            person.call(this,name,age,sex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        var s1 = new student(&quot;张松&quot;,12,&quot;男&quot;,89);</span><br><span class="line">        console.log(s1)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>4.组合继承（借用构造函数+原型）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        function Person(name, age, sex) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line">        Person.prototype.sayhi = function () &#123;</span><br><span class="line">            console.log(&quot;hello&quot; + this.name);</span><br><span class="line">        &#125;</span><br><span class="line">        // var p1 =new Person(&quot;huge&quot;,36,&quot;nan&quot;);</span><br><span class="line">        // console.dir(p1);</span><br><span class="line"></span><br><span class="line">        function Student(score, name, age, sex) &#123;</span><br><span class="line">            this.score = score;</span><br><span class="line">            // 借用构造函数</span><br><span class="line">            // call()方法中第一个参数代表将this指向改为 call()前面的Person中的this</span><br><span class="line">            // 要将其改为谁的就在谁的函数中写    </span><br><span class="line">            Person.call(this, name, age, sex);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 原型继承</span><br><span class="line">        // Student.prototype = Person.prototype;//此写法会出现错误，会使teacher,student指向同一位置</span><br><span class="line">            // 通过原型，让子类型，继承父类型中的方法</span><br><span class="line">        Student.prototype =new Person();</span><br><span class="line">        // 注意当设置prototype必须重新设置他的指向，指向所指的构造函数</span><br><span class="line">        Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 设置Student特有的方法</span><br><span class="line">        Student.prototype.exam = function () &#123;</span><br><span class="line">            console.log(&quot;成绩是&quot; + this.score);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var s1 = new Student(&quot;ning&quot;, 25, &quot;nan&quot;, 98);</span><br><span class="line">        console.log(s1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        function Teacher(name,age,sex,salary)&#123;</span><br><span class="line">            this.salary = salary;</span><br><span class="line">            // 借用构造函数</span><br><span class="line">            Person.call(this,name,age,sex);</span><br><span class="line">        &#125;</span><br><span class="line">        // 原型调用   </span><br><span class="line">        //   通过原型让子类型继承父类型中的方法</span><br><span class="line">        Teacher.prototype = new Person();</span><br><span class="line">        Teacher.prototype.constructor = Teacher;</span><br><span class="line"></span><br><span class="line">        var t1 = new Teacher(&quot;kk&quot;,5,&quot;nan&quot;,5000);</span><br><span class="line">        console.dir(t1);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>5.实例继承</p>
<p><strong>核心：</strong>为父类实例添加新特性，作为子类实例返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">  var instance = new Animal();</span><br><span class="line">  instance.name = name || &apos;Tom&apos;;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); // false</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<p>不限制调用方式，不管是<code>new 子类()</code>还是<code>子类()</code>,返回的对象具有相同的效果</p>
<p>缺点：</p>
<p>实例是父类的实例，不是子类的实例</p>
<p>不支持多继承</p>
<p>6.拷贝继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">  var animal = new Animal();</span><br><span class="line">  for(var p in animal)&#123;</span><br><span class="line">    Cat.prototype[p] = animal[p];</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // false</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>支持多继承</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<h3 id="9、实现跨域的几种方式"><a href="#9、实现跨域的几种方式" class="headerlink" title="9、实现跨域的几种方式"></a>9、实现跨域的几种方式</h3><p>跨域的安全限制都是对<strong>浏览器</strong>端来说的，服务器端是不存在跨域安全限制的。</p>
<p>浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。</p>
<p>如果<strong>协议，端口和主机</strong>对于两个页面是相同的，则两个页面具有相同的源，否则就是不同源的。</p>
<p>如果要在js里发起跨域请求，则要进行一些特殊处理了。或者，你可以把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。</p>
<p>这里讲下使用jquery的jsonp如何发起跨域请求及其原理</p>
<p>1、先看下直接发起ajax请求会怎么样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;跨域测试&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(document).ready(function () &#123;</span><br><span class="line">            </span><br><span class="line">            $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: &apos;http://localhost:9090/student&apos;,</span><br><span class="line">                    type: &apos;GET&apos;,</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        $(text).val(data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;跨域获取数据&quot; /&gt;</span><br><span class="line">    &lt;textarea id=&quot;text&quot; style=&quot;width: 400px; height: 100px;&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>此方式可以看到跨域请求因为浏览器的同源策略被拦截了</p>
<h4 id="1、使用-lt-script-src-””-gt-来完成一个跨域请求："><a href="#1、使用-lt-script-src-””-gt-来完成一个跨域请求：" class="headerlink" title="1、使用 &lt;  script src=”” &gt;来完成一个跨域请求："></a>1、使用 &lt;  script src=”” &gt;来完成一个跨域请求：</h4><p>首先我们需要明白，在页面上直接发起一个跨域的ajax请求是不可以的，但是，在页面上引入不同域上的js脚本却是可以的，就像你可以在自己的页面上使用&lt; img src=”” &gt; 标签来随意显示某个域上的图片一样。</p>
<p>当点击”跨域获取数据”的按钮时，添加一个&lt; script &gt;标签，用于发起跨域请求；注意看请求地址后面带了一个callback=showData的参数；showData即是回调函数名称，传到后台，用于包裹数据。数据返回到前端后，就是showData(result)的形式，因为是script脚本，所以自动调用showData函数，而result就是showData的参数。至此，我们算是跨域把数据请求回来了，但是比较麻烦，需要自己写脚本发起请求，然后写个回调函数处理数据，不是很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">客户端：</span><br><span class="line">&lt;%@ page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;跨域测试&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        //回调函数</span><br><span class="line">        function showData (result) &#123;</span><br><span class="line">            var data = JSON.stringify(result); //json对象转成字符串</span><br><span class="line">            $(&quot;#text&quot;).val(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $(document).ready(function () &#123;</span><br><span class="line"></span><br><span class="line">            $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">                //向头部输入一个脚本，该脚本发起一个跨域请求</span><br><span class="line">                $(&quot;head&quot;).append(&quot;&lt;script src=&apos;http://localhost:9090/student?callback=showData&apos;&gt;&lt;\/script&gt;&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;跨域获取数据&quot; /&gt;</span><br><span class="line">    &lt;textarea id=&quot;text&quot; style=&quot;width: 400px; height: 100px;&quot;&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务端：</span><br><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">    //数据</span><br><span class="line">    List&lt;Student&gt; studentList = getStudentList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    JSONArray jsonArray = JSONArray.fromObject(studentList);</span><br><span class="line">    String result = jsonArray.toString();</span><br><span class="line"></span><br><span class="line">    //前端传过来的回调函数名称</span><br><span class="line">    String callback = request.getParameter(&quot;callback&quot;);</span><br><span class="line">    //用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了</span><br><span class="line">    result = callback + &quot;(&quot; + result + &quot;)&quot;;</span><br><span class="line"></span><br><span class="line">    response.getWriter().write(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109001005441-128129104.png" target="_blank" rel="noopener">https://images2015.cnblogs.com/blog/856154/201701/856154-20170109001005441-128129104.png</a></p>
<p><img src="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109001005441-128129104.png" alt="img"></p>
<h4 id="2、再来看jquery的jsonp方式跨域请求："><a href="#2、再来看jquery的jsonp方式跨域请求：" class="headerlink" title="2、再来看jquery的jsonp方式跨域请求："></a>2、再来看jquery的jsonp方式跨域请求：</h4><p>接下来看如何发起跨域请求。解决跨域请求的方式有很多，这里只说一下jquery的jsop方式及其原理。</p>
<p>服务端代码不变，js代码如下：最简单的方式，只需配置一个dataType:’jsonp’，就可以发起一个跨域请求。jsonp指定服务器返回的数据类型为jsonp格式，可以看发起的请求路径，自动带了一个callback=xxx，xxx是jquery随机生成的一个回调函数名称。</p>
<p>这里的success就跟上面的showData一样，如果有success函数则默认success()作为回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page pageEncoding=&quot;utf-8&quot; contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;跨域测试&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;js/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        $(document).ready(function () &#123;</span><br><span class="line"></span><br><span class="line">            $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line"></span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: &quot;http://localhost:9090/student&quot;,</span><br><span class="line">                    type: &quot;GET&quot;,</span><br><span class="line">                    dataType: &quot;jsonp&quot;, //指定服务器返回的数据类型</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        var result = JSON.stringify(data); //json对象转成字符串</span><br><span class="line">                        $(&quot;#text&quot;).val(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;跨域获取数据&quot; /&gt;</span><br><span class="line">    &lt;textarea id=&quot;text&quot; style=&quot;width: 400px; height: 100px;&quot;&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109004129331-2122753353.png" target="_blank" rel="noopener">https://images2015.cnblogs.com/blog/856154/201701/856154-20170109004129331-2122753353.png</a></p>
<p><img src="https://images2015.cnblogs.com/blog/856154/201701/856154-20170109004129331-2122753353.png" alt="img"></p>
<h4 id="3、cors解决跨域"><a href="#3、cors解决跨域" class="headerlink" title="3、cors解决跨域"></a>3、cors解决跨域</h4><p>​    再补充一点，回到第一条：CORS头缺少“Access-Control-Allow-Origin”。</p>
<p>　　有时候你会发现其它都没问题，出现这个错误：这个错误代表服务端拒绝跨域访问。如果出现这个错误，就需要在服务端设置允许跨域请求。</p>
<p>　　response.setHeader(“Access-Control-Allow-Origin”, “*”); 设置允许任何域名跨域访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//设置可以跨域访问：第6行代码或第8行代码，设置其中一个即可。</span><br><span class="line"></span><br><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">    // * 表示允许任何域名跨域访问</span><br><span class="line">   // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    // 指定特定域名可以访问</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:localhost:8080/&quot;);</span><br><span class="line"></span><br><span class="line">    //数据</span><br><span class="line">    List&lt;Student&gt; studentList = getStudentList();</span><br><span class="line"></span><br><span class="line">    JSONArray jsonArray = JSONArray.fromObject(studentList);</span><br><span class="line">    String result = jsonArray.toString();</span><br><span class="line"></span><br><span class="line">    //前端传过来的回调函数名称</span><br><span class="line">    String callback = request.getParameter(&quot;callback&quot;);</span><br><span class="line">    //用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了</span><br><span class="line">    result = callback + &quot;(&quot; + result + &quot;)&quot;;</span><br><span class="line"></span><br><span class="line">    response.getWriter().write(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    1.jQuery ajax方式以jsonp类型发起跨域请求，其原理跟&lt; script&gt;脚本请求一样，因此使用jsonp时也只能使用GET方式发起跨域请求。跨域请求需要服务端配合，设置callback，才能完成跨域请求。</p>
<p>​    2.可以看到，jsonp方式不支持POST方式跨域请求，就算指定成POST方式，会自动转为GET方式；</p>
<p>​    3.jsonp的实现方式其实就是&lt; script&gt;脚本请求地址的方式一样，只是ajax的jsonp对其做了封装，所以可想而知，jsonp是不支持POST方式的。</p>
<h3 id="10、浮动及清除浮动的几种方式？"><a href="#10、浮动及清除浮动的几种方式？" class="headerlink" title="10、浮动及清除浮动的几种方式？"></a>10、浮动及清除浮动的几种方式？</h3><p>浮动是什么？</p>
<p>浮动元素会脱离文档流进行左浮或者右浮，直到碰到父级元素或者其他的浮动元素。</p>
<p>为什么清除浮动：浮动会导致父元素高度坍塌，因为浮动脱离文档流，浮动以后不占文档流的位置，撑开的父元素高度肯定会坍塌。</p>
<p>清除浮动的八种方法：</p>
<p>1、父级div给出固定的高度。手动定义height，这样就解决了父级元素获取不到高度的问题。</p>
<p>优点：代码量少，简单容易掌握。</p>
<p>缺点：只适合高度固定的布局，如果高度和父级div不同会出现问题。</p>
<p>2、overflow，设置overflow：hidden。</p>
<p>优点：代码少，浏览器支持。</p>
<p>缺点：会把超出的部分隐藏起来，而且不能配合position使用</p>
<p>3、额外标签，添加一个新的标签，如div，或者br，并且设置标签的属性clear：both；清除浮动，让父级能自动获得高度。</p>
<p>优点：代码少，浏览器支持，不会各种问题。</p>
<p>缺点：会有很多空的div或者br。</p>
<p>4、使用单伪类after和zoom，使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.clearfloat:after&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　  content:&quot;&quot;;//设置内容为空</span><br><span class="line"></span><br><span class="line">　　　　　  height:0;//高度为0</span><br><span class="line"></span><br><span class="line">　　　　　　  line-height:0;//行高为0</span><br><span class="line"></span><br><span class="line">　　　　　　  display:block;//将文本转为块级元素</span><br><span class="line"></span><br><span class="line">　　　　　　  visibility:hidden;//将元素隐藏</span><br><span class="line"></span><br><span class="line">　　　　　　  clear:both//清除浮动</span><br><span class="line"></span><br><span class="line">　 &#125;</span><br><span class="line"></span><br><span class="line">　　　　  .clearfloat&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　 zoom:1;为了兼容IE</span><br><span class="line"></span><br><span class="line">　　   　&#125;</span><br></pre></td></tr></table></figure>
<p>优点：浏览器支持好，大型的浏览器都在使用，建议使用。</p>
<p>缺点：代码多，需要after和zoom都要使用才能兼容主流的浏览器。</p>
<p>5、双伪类清除浮动。使用方法：</p>
<p>　.clearfloat:before,.clearfloatafter {</p>
<pre><code>      content: &quot;&quot;;

      display: block;

       clear: both;

  }

 .clearfloat {

      zoom: 1;

}
</code></pre><p>缺点：不严谨不建议使用</p>
<p>6、父级div跟着浮动，所有代码一起浮动就会形成一个整体，</p>
<p>缺点：会产生新的问题，不建议使用。</p>
<p>7、父级定义display：table；将div属性变成的表格。</p>
<p>缺点：产生新的问题，而且影响布局。</p>
<p>8、overflow：auto；需要设置width，不设置height，浏览器会自动检测浮动区的高度。</p>
<p>缺点：容易生成滚动条。</p>
<h3 id="11、cookie-sessionStorage-localStorage的区别"><a href="#11、cookie-sessionStorage-localStorage的区别" class="headerlink" title="11、cookie,sessionStorage,localStorage的区别"></a>11、cookie,sessionStorage,localStorage的区别</h3><p>​    浏览器的缓存机制提供了可以将用户数据存储在<strong>客户端</strong>上的方式，可以利用cookie,session等跟服务端进行数据交互。</p>
<h4 id="一、cookie和session"><a href="#一、cookie和session" class="headerlink" title="一、cookie和session"></a>一、cookie和session</h4><p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>区别：</p>
<p>1、保持状态：cookie保存在浏览器端，session保存在服务端</p>
<p>2、使用方式：</p>
<p>（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p>
<p>​     Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p>
<p>（2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</p>
<p>3、存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</p>
<p>4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。</p>
<p>5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。</p>
<p>　　　　　　原因如下：（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；</p>
<p>　　　　　　　　　　　（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；</p>
<p>　　　　　　　　　　　（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。</p>
<p>　　　　　　　　　　　（4）sessionID是加密的</p>
<p>　　　　　　　　　　　（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。</p>
<p>6、应用场景：</p>
<p>cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>
<p>　　　　（2）保存上次登录的时间等信息。</p>
<p>　　　　（3）保存上次查看的页面</p>
<p>　　　　（4）浏览计数</p>
<p><img src="https://images2017.cnblogs.com/blog/1209205/201709/1209205-20170928000104559-1868896430.png" alt="img"></p>
<p>session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。</p>
<p>　　（1）网上商城中的购物车</p>
<p>　　（2）保存用户登录信息</p>
<p>　　（3）将某些数据放入session中，供同一用户的不同页面使用</p>
<p>　　（4）防止用户非法登录</p>
<p> 7、缺点：cookie（1）大小受限</p>
<p>　　　　　　　　（2）用户可以操作（禁用）cookie，使功能受限</p>
<p>　　　　　　　　（3）安全性较低</p>
<p>　　　　　　　　（4）有些状态不可能保存在客户端。</p>
<p><code>（5）每次访问都要传送cookie给服务器，浪费带宽。</code></p>
<p>　　　　　　　　（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
<p> 　　　session：（1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>
<p>　　　　　　　　（2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</p>
<p>　　　　　　　　（3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p>
<p>二、WebStorage</p>
<p>WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p>
<p>WebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。</p>
<p>HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。</p>
<p>1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p>
<p>　　　　　　  sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p>
<p>2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB</p>
<p>3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。</p>
<p>4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<p>5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。</p>
<p>6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</p>
<p>WebStorage的优点：</p>
<p>（1）存储空间更大：cookie为4KB，而WebStorage是5MB；</p>
<p>（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；</p>
<p>（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；</p>
<p>（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；</p>
<p>（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；</p>
<p>（6）WebStorage提供了一些方法，数据操作比cookie方便；</p>
<p>　　　　setItem (key, value) ——  保存数据，以键值对的方式储存信息。</p>
<p>​      　　 getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</p>
<p>​        　　removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</p>
<p>​        　　clear () ——  删除所有的数据</p>
<p>​        　　key (index) —— 获取某个索引的key</p>
<h3 id="12、继承的几种方式"><a href="#12、继承的几种方式" class="headerlink" title="12、继承的几种方式"></a>12、继承的几种方式</h3><p>extend</p>
<p>原型继承</p>
<p>借用构造函数继承</p>
<p>组合继承</p>
<h3 id="13、rem、em、px的区别"><a href="#13、rem、em、px的区别" class="headerlink" title="13、rem、em、px的区别"></a>13、rem、em、px的区别</h3><h4 id="px："><a href="#px：" class="headerlink" title="px："></a>px：</h4><p>像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p>
<p>特点：</p>
<p>\1. IE无法调整那些使用px作为单位的字体大小；</p>
<p>\2. 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；</p>
<p>\3. Firefox能够调整px和em，rem</p>
<h4 id="em："><a href="#em：" class="headerlink" title="em："></a>em：</h4><p>相对长度单位，相对于当前对象内文本的字体尺寸。任意浏览器的默认字体高都是16px，所以未经调整的浏览器都符合: 1em=16px。</p>
<p>特点：</p>
<p>\1. em的值并不是固定的；</p>
<p>\2. em会继承父级元素的字体大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;font-size:20px;&quot;&gt;</span><br><span class="line">    &lt;p style=&quot;font-size:1em;&quot;&gt;这里1em=20px&lt;/p&gt;</span><br><span class="line">    &lt;p style=&quot;font-size:2em;&quot;&gt;这里2em=40px&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子就说明了em的值并非固定的，他是根据父元素的字体大小来决定的。如果父元素设置了font-size:20px，那么1em=20px，2em=40px；如果父元素设置了font-size:30px，那么1em=30px，2em=60px。依次类推。</p>
<h4 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h4><p>是CSS3新增的一个相对单位，可以理解为”root em”，相对于根节点html的字体大小来计算的，chrome/firefox/IE9+支持。任意浏览器的默认字体高都是16px，所以未经调整的浏览器都符合: 1rem=16px。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html style=&quot;font-size:100px;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;p style=&quot;font-size:1rem;&quot;&gt;这里1rem=100px&lt;/p&gt;</span><br><span class="line">     &lt;div style=&quot;font-size:50px;&quot;&gt;</span><br><span class="line">          &lt;p style=&quot;font-size:2rem;&quot;&gt;这里2rem=200px&lt;/p&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子说明了，rem的值只受到根节点html的字体大小影响，并不受父元素字体大小的影响。如果根节点html设置了font-size:100px，那么1rem=100px，2rem=200px；如果根节点html设置了font-size:200px，那么1rem=200px，2rem=400px。依次类推。</p>
<p>rem和em在为元素设置字体大小时，都是相对大小。区别在于：使用rem时，相对的只是HTML根元素。</p>
<p>rem这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    谷歌浏览器chrome强制最小字体为12px，因此即使设置了小于12px的值，也会显示成12px。因此，当你给html设置font-size:10px时，1rem并不是等于10px，而是等于12px</p>
<p>​    具体使用哪种字体单位，还是要根据项目实际情况来定的。rem更加适合不用考虑低版本浏览器兼容问题的项目来使用。</p>
<h3 id="14、举例IE的兼容性问题（ie常见bug）"><a href="#14、举例IE的兼容性问题（ie常见bug）" class="headerlink" title="14、举例IE的兼容性问题（ie常见bug）"></a>14、举例IE的兼容性问题（ie常见bug）</h3><p>常见的兼容性问题：<br>1、不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同<br>解决方案： css 里增加通配符 * { margin: 0; padding: 0; }</p>
<p>2、<strong>IE6双边距问题</strong>；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题<br>解决方案：设置display:inline;</p>
<p>3、当<strong>标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度</strong><br>解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度</p>
<p>4、图片默认有间距<br>解决方案：使用float 为img 布局</p>
<p>5、I<strong>E9以下浏览器不能使用opacity</strong><br>解决方案：<br>opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</p>
<p>6、边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；<br>解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；</p>
<p>7、cursor:hand 显示手型在safari 上不支持<br>解决方案：统一使用 cursor:pointer</p>
<p>8、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；</p>
<p>解决方案：父级元素设置position:relative</p>
<h3 id="15、jq中链式编程"><a href="#15、jq中链式编程" class="headerlink" title="15、jq中链式编程"></a>15、jq中链式编程</h3><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p><strong>1.好处</strong></p>
<p><strong>“一句话，链式编程可以省去很多重复的代码。”</strong></p>
<p><strong>这话**</strong>什么意思呢？<strong>**举个例子。</strong></p>
<p>/<em>设置obj对象的两个属性</em>/</p>
<p>//普通做法是这样的</p>
<p>obj.name = ‘小明’;</p>
<p>obj.age =  155；</p>
<p>//链式编程是这样的。</p>
<p>obj.name(‘小明’).age(15);</p>
<p><strong>2.**</strong>注意** </p>
<p>链式编程注意：</p>
<p>$(‘div’).html(‘设置值’).val(‘设置值’);这样是可以的。</p>
<p>但是$(‘div’).html().text()这样是不对的，因为获取值时返回的是获取的字符串而不是对象本身所以不能链式编程。</p>
<p><strong>3.**</strong>断链了咋整**</p>
<p>链式编程的时候一定要注意在什么时候“破坏”了链，当前对象的传递，如果传递被破坏，则继续链式编程会有意想不到的结果！nextAll(),prevAll(),sibilings()</p>
<p>如何解决：调用end()方法。（返回链 被破坏前的对象。）</p>
<h3 id="16、双倍边距"><a href="#16、双倍边距" class="headerlink" title="16、双倍边距"></a>16、双倍边距</h3><p>描述：在IE6中，一个居左（或居右）浮动的元素放置进一个容器盒(box)，并在浮动元素上使用了左边距(或右边距) 在ie6内便产生双倍边距。<br>hack:给浮动元素添加声明：display:inline;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1     &lt;title&gt;IE6双倍边距&lt;/title&gt;</span><br><span class="line"> 2     &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"> 3         *&#123;</span><br><span class="line"> 4             margin: 0;</span><br><span class="line"> 5             padding: 0;</span><br><span class="line"> 6         &#125;</span><br><span class="line"> 7 </span><br><span class="line"> 8         .box1 &#123;</span><br><span class="line"> 9             /*display: inline; 给产生双倍间距的元素添加此属性即可恢复正常*/</span><br><span class="line">10             float: left;</span><br><span class="line">11             width: 100px;</span><br><span class="line">12             height: 100px;</span><br><span class="line">13             margin: 0 50px;</span><br><span class="line">14             background: orange;</span><br><span class="line">15         &#125;</span><br><span class="line">16 </span><br><span class="line">17         .box2 &#123;</span><br><span class="line">18             float: left;</span><br><span class="line">19             width: 100px;</span><br><span class="line">20             height: 100px;</span><br><span class="line">21             background: green;</span><br><span class="line">22         &#125;</span><br><span class="line">23 </span><br><span class="line">24 </span><br><span class="line">25     &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;body&gt;</span><br><span class="line">2     &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">3     &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">4 &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>正常效果：</p>
<p><a href="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817111910680-801527203.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817111910680-801527203.png</a></p>
<p><img src="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817111910680-801527203.png" alt="img"></p>
<p>IE6效果：</p>
<p><a href="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817112043763-1535904519.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817112043763-1535904519.png</a></p>
<p><img src="https://images2018.cnblogs.com/blog/1249006/201808/1249006-20180817112043763-1535904519.png" alt="img"></p>
<p>可见在ie6中产生了<strong>双倍间距</strong>，</p>
<p>决绝方法给产生双倍间距的<strong>浮动元素添加  display:inline; </strong>即可解决问题</p>
<h3 id="17、手写数组去重，冒泡排序"><a href="#17、手写数组去重，冒泡排序" class="headerlink" title="17、手写数组去重，冒泡排序"></a>17、手写数组去重，冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 13  数组去重</span><br><span class="line">       // 第一种 最普通的</span><br><span class="line">       // var arr = [5,6,4,8,9,25,5,6,8];</span><br><span class="line">       // var arr1 = [];</span><br><span class="line">       // function first(atgs)&#123;</span><br><span class="line">       //     for(var i=0;i&lt;atgs.length;i++)&#123;</span><br><span class="line">       //         if(arr1.indexOf(atgs[i])==-1)&#123;</span><br><span class="line">       //             arr1.push(atgs[i]);</span><br><span class="line">       //         &#125;</span><br><span class="line">       //     &#125;</span><br><span class="line">       //     return arr1;</span><br><span class="line">       //  &#125;</span><br><span class="line">       //  console.log(first(arr));</span><br><span class="line"></span><br><span class="line">       // 第二种  排序相邻去重法</span><br><span class="line">      function sort(a,b)&#123;</span><br><span class="line">           return a-b;</span><br><span class="line">       &#125;</span><br><span class="line">       // function att(array)&#123;</span><br><span class="line">       //     array.sort(); //先将数组排序</span><br><span class="line">       //     var tem = [array[0]];</span><br><span class="line">       //     for(var i=1;i&lt;array.length;i++)&#123;</span><br><span class="line">       //         if(array[i]!==tem[tem.length-1])&#123;</span><br><span class="line">       //             tem.push(array[i]);</span><br><span class="line">       //         &#125;</span><br><span class="line">       //     &#125;</span><br><span class="line">       //     return tem;</span><br><span class="line">       // &#125;</span><br><span class="line">       // var arr = [5,6,4,8,9,25,5,6,8];</span><br><span class="line">       // console.log(att(arr));</span><br><span class="line"></span><br><span class="line">       // 第三种 </span><br><span class="line">       // 思路：获取没重复的最右一值放入新数组</span><br><span class="line">       /*</span><br><span class="line">        * 推荐的方法</span><br><span class="line">        *</span><br><span class="line">        * 方法的实现代码相当酷炫，</span><br><span class="line">        * 实现思路：获取没重复的最右一值放入新数组。</span><br><span class="line">        * （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/</span><br><span class="line">       // function uniq(array)&#123;</span><br><span class="line">       //     var temp = [];</span><br><span class="line">       //     var index = [];</span><br><span class="line">       //     var l = array.length;</span><br><span class="line">       //     for(var i = 0; i &lt; l; i++) &#123;</span><br><span class="line">       //         for(var j = i + 1; j &lt; l; j++)&#123;</span><br><span class="line">       //             if (array[i] === array[j])&#123;</span><br><span class="line">       //                 i++;</span><br><span class="line">       //                 j = i;</span><br><span class="line">       //             &#125;</span><br><span class="line">       //         &#125;</span><br><span class="line">       //         temp.push(array[i]);</span><br><span class="line">       //         index.push(i);</span><br><span class="line">       //     &#125;</span><br><span class="line">       //     console.log(index);</span><br><span class="line">       //     return temp;</span><br><span class="line">       // &#125;</span><br><span class="line"></span><br><span class="line">       // var aa = [1,2,2,3,5,3,6,5];</span><br><span class="line">       // console.log(uniq(aa));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var examplearr=[8,94,15,88,55,76,21,39];</span><br><span class="line">function sortarr(arr)&#123;</span><br><span class="line">    for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                var temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+1];</span><br><span class="line">                arr[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">sortarr(examplearr);</span><br><span class="line">console.log(examplearr);</span><br><span class="line"></span><br><span class="line">两个循环</span><br><span class="line">当i=0的时候，里面的循环完整执行，从j=0执行到j=6,这也就是第一遍排序，结果是将最大的数排到了最后，这一遍循环结束后的结果应该是[8,15,88,55,76,21,39,94]</span><br><span class="line">当i=1的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，这也是j&lt;arr.length-1-i的巧妙之处，结果是[8,15,55,76,21,39,88,94]</span><br><span class="line">说到这里，规律就清楚了，每次将剩下数组里面最大的一个数排到最后面，当第一个循环执行到最后的时候，也就是i=6,此时，j=0,只需要比较数组的第一和第二项，比较完毕，返回。</span><br></pre></td></tr></table></figure>
<h3 id="18、ajax用js的实现"><a href="#18、ajax用js的实现" class="headerlink" title="18、ajax用js的实现"></a>18、ajax用js的实现</h3><p><a href="https://www.cnblogs.com/colima/p/5339227.html" target="_blank" rel="noopener">原生js实现Ajax</a></p>
<p>JQuery提供的Ajax方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: ,</span><br><span class="line">    type: &apos;&apos;,</span><br><span class="line">    dataType: &apos;&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">          </span><br><span class="line">    &#125;,</span><br><span class="line">    success: function()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;,</span><br><span class="line">    error: function()&#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>原生js实现Ajax方法：</p>
<p>(1) 创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>(2) 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>(3)设置响应HTTP请求状态变化的函数.<br>(4)发送HTTP请求.<br>(5)获取异步调用返回的数据. </p>
<p>(6)使用JavaScript和DOM实现局部刷新.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var Ajax=&#123;</span><br><span class="line">  get: function(url, fn) &#123;</span><br><span class="line">    //创建异步对象 XMLHttpRequest对象用于在后台与服务器交换数据   </span><br><span class="line">    var xhr = new XMLHttpRequest();   </span><br><span class="line">    //设置请求行    get请求如果有参数拼接在url后面  post若有参数，在请求体中拼接</span><br><span class="line">    xhr.open(&apos;GET&apos;, url, true);</span><br><span class="line">    //设置请求头  get不用设置  post需要设置</span><br><span class="line">    //</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      // readyState 0=&gt;初始化 1=&gt;载入 2=&gt;载入完成 3=&gt;解析 4=&gt;完成</span><br><span class="line">      // readyState == 4说明请求已完成（响应内容以解析完毕）xhr.status == 200判断服务器响应成功</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304 ) &#123; </span><br><span class="line">        // 从服务器获得数据 </span><br><span class="line">        fn.call(this, xhr.responseText);  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置请求体  post在此处传递参数，get不用在此处传递</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;,</span><br><span class="line">  // data 应为&apos;a=a1&amp;b=b1&apos;查询字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式</span><br><span class="line">  post: function (url, data, fn) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;POST&quot;, url, true);</span><br><span class="line">    // 添加http头，发送信息至服务器时内容编码类型</span><br><span class="line">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200|| xhr.status == 304)) &#123;</span><br><span class="line">        fn.call(this, xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<p>\1. open(method, url, async) 方法需要三个参数:</p>
<p>　 method：发送请求所使用的方法（GET或POST）；与POST相比，GET更简单也更快，并且在大部分情况下都能用；然而，在以下情况中，请使用POST请求：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<p>　url：规定服务器端脚本的 URL(该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）)；</p>
<p>　async：规定应当对请求进行异步（true）或同步（false）处理；true是在等待服务器响应时执行其他脚本，当响应就绪后对响应进行处理；false是等待服务器响应再执行。</p>
<p>\2. send() 方法可将请求送往服务器。</p>
<p>\3. onreadystatechange：存有处理服务器响应的函数，每当 readyState 改变时，onreadystatechange 函数就会被执行。</p>
<p>\4. readyState：存有服务器响应的状态信息。</p>
<ul>
<li>0: 请求未初始化（代理被创建，但尚未调用 open() 方法）</li>
<li>1: 服务器连接已建立（<code>open</code>方法已经被调用）</li>
<li>2: 请求已接收（<code>send</code>方法已经被调用，并且头部和状态已经可获得）</li>
<li>3: 请求处理中（下载中，<code>responseText</code> 属性已经包含部分数据）</li>
<li>4: 请求已完成，且响应已就绪（下载操作已完成）</li>
</ul>
<p>\5. responseText：获得字符串形式的响应数据。</p>
<ol>
<li>setRequestHeader()：POST传数据时，用来添加 HTTP 头，然后send(data)，注意data格式；GET发送信息时直接加参数到url上就可以，比如url?a=a1&amp;b=b1。</li>
</ol>
<p><strong>PS</strong>：Fetch polyfill 的基本原理是探测是否存在window.fetch方法，如果没有则用 XHR 实现。</p>
<h3 id="19、状态码"><a href="#19、状态码" class="headerlink" title="19、状态码"></a>19、状态码</h3><p><a href="http://pretty-rfc.herokuapp.com/RFC2616" target="_blank" rel="noopener">RFC2616</a>定义的状态码，由3位数字和原因短信组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Reason-phrase</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational</td>
<td>信息性状态码，表示接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success</td>
<td>成功状态码，表示请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection</td>
<td>重定向状态码，表示需要客户端需要进行附加操作</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error</td>
<td>客户端错误状态码，表示服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error</td>
<td>服务器错误状态码，表示服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>200 OK     请求被成功处理</p>
<p>204 No Content    表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.</p>
<p>301 Movied Permanently        永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI</p>
<p>302 Found    临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问</p>
<p>307 Temporary Redirect    临时重定向</p>
<p>400 Bad Request    表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>
<p>403 Forbidden    该状态码表明对请求资源的访问被服务器拒绝了</p>
<p>404 Not Found    该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>
<p>500 Internal Server Error    该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>
<p>503 Service Unavailable    该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>
<h3 id="20、http的请求方式"><a href="#20、http的请求方式" class="headerlink" title="20、http的请求方式"></a>20、http的请求方式</h3><p>什么是http协议？</p>
<p>　　http协议，是互联网中最常见的网络通信标准。</p>
<p>http协议的特点</p>
<p>　　①通信流程：断开式（无状态）</p>
<p>　　　　　　　　断开式：http协议每次响应完成后，会断开与客户端的连接</p>
<p>　　　　　　　　无状态：由于服务器断开了之前的连接，就无法知晓连接间的关系</p>
<p>　　②内容格式：消息头和消息体</p>
<p>HTTP请求的方法：<br>HTTP/1.1协议中共定义了<strong>八种方法</strong>（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式</p>
<p>1、OPTIONS<br>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性<br>2、HEAD<br>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。<br>3、GET<br>向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。<br>4、POST<br>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form<br>5、PUT<br>向指定资源位置上传其最新内容<br>6、DELETE<br>请求服务器删除Request-URL所标识的资源<br>7、TRACE<br>回显服务器收到的请求，主要用于测试或诊断<br>8、CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>注意：<br>1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。<br>2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。
　　</p>
<p>get 和 post区别</p>
<p>　　区别：</p>
<p>　　　　get请求无消息体，只能携带少量数据</p>
<p>　　　　post请求有消息体，可以携带大量数据</p>
<p>　　携带数据的方式：</p>
<p>　　　　get请求将数据放在url地址中</p>
<p>　　　　 post请求将数据放在消息体中</p>
<p>GET请求请提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中； </p>
<p>GET方式提交的数据最多只能有1024字节，而POST则没有此限制。 </p>
<h3 id="21、H5C3新特性"><a href="#21、H5C3新特性" class="headerlink" title="21、H5C3新特性"></a>21、H5C3新特性</h3><p>html5的新特性：</p>
<p>1.语义话标签</p>
<p>&lt; header&gt;  &lt; footer&gt;  &lt; article&gt;  &lt; section&gt;</p>
<p>2.新增表单类型</p>
<p>search   email  url  number   tel  calender  time</p>
<p>3.新增表单属性</p>
<p>autocomplete 控制自动完成功能</p>
<p>4.新增api</p>
<p>自定义属性data-,拖拽释放（Drag and drop)</p>
<p>5.多媒体</p>
<p>音频，视频audio,video,</p>
<p>6.es6标准</p>
<p>7.canavas绘图</p>
<p>8、新技术 ：地图geolocation   websocket</p>
<p>c3新特性：</p>
<p>1.</p>
<h3 id="22、页面优化的方式"><a href="#22、页面优化的方式" class="headerlink" title="22、页面优化的方式"></a>22、页面优化的方式</h3><h4 id="一、减少HTTP请求"><a href="#一、减少HTTP请求" class="headerlink" title="一、减少HTTP请求"></a>一、减少HTTP请求</h4><p>1.CSS Sprites</p>
<p>CSS Sprites直译过来就是CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，然后通过CSS的一些技术布局到网页上。特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。</p>
<p>2.字体图标</p>
<p>在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少http请求，字体图标还可以通过CSS来设置颜色、大小等样式，何乐而不为。</p>
<p>3.合并脚本 和样式表</p>
<p>将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。</p>
<p>然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。</p>
<p>4.图片很多时，使用懒加载</p>
<h4 id="二、使用CDN"><a href="#二、使用CDN" class="headerlink" title="二、使用CDN"></a>二、使用CDN</h4><p>（CDN的全称是Content Delivery Network即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265" target="_blank" rel="noopener">内容分发网络</a>）</p>
<p>如果应用程序web服务器离用户更近，那么一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器离用户更近，则多个HTTP请求的响应时间将缩短。</p>
<p> CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。</p>
<p>CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力。</p>
<p>CDN的缺点：</p>
<p>1、响应时间可能会受到其他网站流量的影响。CDN服务提供商在其所有客户之间共享Web服务器组。</p>
<p>2、如果CDN服务质量下降了，那么你的工作质量也将下降</p>
<p>3、无法直接控制组件服务器</p>
<h4 id="三、添加Expires头（Expires：协议）"><a href="#三、添加Expires头（Expires：协议）" class="headerlink" title="三、添加Expires头（Expires：协议）"></a>三、添加Expires头（Expires：协议）</h4><p>页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。</p>
<p>Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：</p>
<p>Expires: Fri, 18 Mar 2016 07:41:53 GMT</p>
<p>Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查</p>
<p>HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。</p>
<p>Cache-Control： max-age=12345600</p>
<p>若同时制定Cache-Control和Expires，则max-age将覆盖Expires头</p>
<h4 id="四、压缩组件"><a href="#四、压缩组件" class="headerlink" title="四、压缩组件"></a>四、压缩组件</h4><p>从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持</p>
<p>Accept-Encoding: gzip,deflate</p>
<p>如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的Content-Encoding来通知 Web客户端。</p>
<p>Content-Encoding: gzip</p>
<p>代理缓存</p>
<p>当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。</p>
<p>解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。</p>
<p>vary: Accept-Encoding</p>
<h4 id="五、将样式表放在头部"><a href="#五、将样式表放在头部" class="headerlink" title="五、将样式表放在头部"></a>五、将样式表放在头部</h4><p>首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。</p>
<p>我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。</p>
<p>将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西 </p>
<h4 id="六、将脚本放在底部"><a href="#六、将脚本放在底部" class="headerlink" title="六、将脚本放在底部"></a>六、将脚本放在底部</h4><p>更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。</p>
<p>js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。</p>
<p>下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。</p>
<h4 id="七、避免CSS表达式"><a href="#七、避免CSS表达式" class="headerlink" title="七、避免CSS表达式"></a>七、避免CSS表达式</h4><p>CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    width: expression(func(),document.body.clientWidth &gt; 400 ? &quot;400px&quot; : &quot;auto&quot;);</span><br><span class="line">    height: 80px;</span><br><span class="line">    border: 1px solid #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var n = 0;</span><br><span class="line">    function func() &#123;</span><br><span class="line">        n++;</span><br><span class="line">        // alert();</span><br><span class="line">        console.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><img src="https://images2015.cnblogs.com/blog/861963/201603/861963-20160318180203631-843727359.png" alt="img"></p>
<p>鼠标移动了几次，函数的运行次数轻而易举的达到了几千次，危险性显而易见。</p>
<p>如何解决：</p>
<p><strong>一次性表达式：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    width: expression(func(this));</span><br><span class="line">    height: 80px;</span><br><span class="line">    border: 1px solid #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var n = 0;</span><br><span class="line">    function func(elem) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        elem.style.width = document.body.clientWidth &gt; 400 ? &apos;400px&apos; : &quot;auto&quot;;</span><br><span class="line">        console.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>事件处理机制</strong></p>
<p>用js事件处理机制来动态改变元素的样式，使函数运行次数在可控范围之内。</p>
<h4 id="八、使用外部的JavaScript和CSS"><a href="#八、使用外部的JavaScript和CSS" class="headerlink" title="八、使用外部的JavaScript和CSS"></a>八、使用外部的JavaScript和CSS</h4><p>内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。</p>
<p>影响因素：</p>
<p>1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。</p>
<p>2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。</p>
<h4 id="九、减少DNS查找"><a href="#九、减少DNS查找" class="headerlink" title="九、减少DNS查找"></a>九、减少DNS查找</h4><p>当我们在浏览器的地址栏输入网址回车这一瞬间到看到页面到底发生了什么呢？</p>
<p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p>
<p>域名解析是页面加载的第一步</p>
<p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p>
<p>当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。</p>
<p>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。</p>
<h4 id="十、精简JavaScript"><a href="#十、精简JavaScript" class="headerlink" title="十、精简JavaScript"></a>十、精简JavaScript</h4><p><strong>精简</strong></p>
<p>精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。</p>
<p><strong>混淆</strong></p>
<p>混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。</p>
<p>缺点：</p>
<p>混淆本身比较复杂，可能会引入错误。</p>
<p>需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。</p>
<p>混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。</p>
<p>在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。</p>
<p><strong>CSS的精简</strong></p>
<p>CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。</p>
<p>除了移除空白、注释之外，CSS可以通过优化来获得更多的节省：</p>
<p>合并相同的类；</p>
<p>移除不使用的类；</p>
<p>使用缩写</p>
<p>jquery-2.0.3的学习版（未精简）和精简版，可见精简文件的大小比源文件小了155k，而且，在精简版中jquery还做了混淆，譬如用e代替window等，从而获得最大的节省。</p>
<h4 id="十一、避免重定向"><a href="#十一、避免重定向" class="headerlink" title="十一、避免重定向"></a>十一、避免重定向</h4><p><strong>什么是重定向？</strong></p>
<p>重定向用于将用户从一个URL重新路由到另一个URL。</p>
<p><strong>常用重定向的类型</strong></p>
<p>301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。</p>
<p>302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。</p>
<p>304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。</p>
<p><strong>重定向如何损伤性能?</strong></p>
<p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p>
<p><strong>重定向的应用场景</strong></p>
<ol>
<li>跟踪内部流量</li>
<li>跟踪出站流量</li>
</ol>
<p>除了重定向外，我们还可以选择使用信标(beacon)——一个HTTP请求，其URL中包含有跟踪信息。跟踪信息可以从信标Web服务器的访问日记中提取出来，信标通常是一个1px*1px的透明图片，不过204响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。</p>
<h4 id="十二、删除重复脚本"><a href="#十二、删除重复脚本" class="headerlink" title="十二、删除重复脚本"></a>十二、删除重复脚本</h4><p>在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多次。</p>
<p>重复的脚本会造成不必要的HTTP请求（如果没有缓存该脚本的话），并且执行多余的JavaScript浪费时间，还有可能造成错误。</p>
<p>如何避免重复脚本呢？</p>
<p>\1. 形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是必要的，所以需要对脚本进行一个良好的组织。</p>
<p>\2. 实现脚本管理器模块。</p>
<h4 id="十三、使Ajax可缓存"><a href="#十三、使Ajax可缓存" class="headerlink" title="十三、使Ajax可缓存"></a>十三、使Ajax可缓存</h4><p>维基百科中这样定义Ajax：</p>
<blockquote>
<p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。Ajax的概念由杰西·詹姆士·贾瑞特所提出。</p>
<p>传统的Web应用允许用户端填写表单（form），当提交表单时就向Web服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p>
<p>与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p>
<p>类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。而客户端与服务器也并不需要异步。一些基于AJAX的“派生／合成”式（derivative/composite）的技术也正在出现，如AFLAX。</p>
</blockquote>
<p>Ajax的目地是为突破web本质的开始—停止交互方式，向用户显示一个白屏后重绘整个页面不是一种好的用户体验。</p>
<p><strong>异步与即时</strong></p>
<p>Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。</p>
<p>用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动请求是基于用户当前的操作而发起的</p>
<p><strong>什么样的AJAX请求可以被缓存？</strong></p>
<p>POST的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（可以在服务器端对数据进行缓存，以便提高处理速度）</p>
<p>GET的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的AJAX请求，不会重复在服务器执行，而是返回304。</p>
<p><strong>Ajax请求使用缓存</strong></p>
<p>在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度。</p>
<h4 id="十四、加载后下载"><a href="#十四、加载后下载" class="headerlink" title="十四、加载后下载"></a>十四、加载后下载</h4><p>有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成止呕动态加载外部组件，以便用户接下来的访问。</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1   function doOnload() &#123;</span><br><span class="line"> 2       setTimeout(&quot;downloadFile()&quot;,1000);</span><br><span class="line"> 3   &#125;</span><br><span class="line"> 4   </span><br><span class="line"> 5   window.onload = doOnload;</span><br><span class="line"> 6   </span><br><span class="line"> 7   function downloadFile() &#123;</span><br><span class="line"> 8       downloadCss(&quot;http://abc.com/css/a.css&quot;);</span><br><span class="line"> 9       downloadJS(&quot;http://abc.com/js/a.js&quot;);</span><br><span class="line">10  &#125;</span><br><span class="line">11  </span><br><span class="line">12  function downloadCss(url) &#123;</span><br><span class="line">13      var ele = document.createElement(&apos;link&apos;);</span><br><span class="line">14      ele.rel = &quot;stylesheet&quot;;</span><br><span class="line">15      ele.type = &quot;text/css&quot;;</span><br><span class="line">16      ele.href = url;</span><br><span class="line">17  </span><br><span class="line">18      document.body.appendChild(ele);</span><br><span class="line">19  &#125;</span><br><span class="line">20  </span><br><span class="line">21  function downloadJS(url) &#123;</span><br><span class="line">22      var ele = document.createElement(&apos;script&apos;);</span><br><span class="line">23      ele.src = url;</span><br><span class="line">24      document.body.appendChild(ele);</span><br><span class="line">25  &#125;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>在该页面中，JavaScript和CSS被加载两次（内联和外部）。要使其正常工作，必须处理双重定义。将这些组件放到一个不可见的IFrame中是一个比较好的解决方式。</p>
<h3 id="23、css优化提高性能的方法"><a href="#23、css优化提高性能的方法" class="headerlink" title="23、css优化提高性能的方法"></a>23、css优化提高性能的方法</h3><h3 id="24、vue相关知识点（开发中遇到的问题）"><a href="#24、vue相关知识点（开发中遇到的问题）" class="headerlink" title="24、vue相关知识点（开发中遇到的问题）"></a>24、vue相关知识点（开发中遇到的问题）</h3><h3 id="25、数组的几种操作方式"><a href="#25、数组的几种操作方式" class="headerlink" title="25、数组的几种操作方式"></a>25、数组的几种操作方式</h3><p>push()     方法可向数组的末尾添加一个或多个元素，并返回新的长度   此方法改变数组的长度</p>
<p>pop()   删除数组的最后一个元素并返回删除的元素。此方法改变数组的长度！</p>
<p>shift（）把数组的第一个元素从其中删除，并返回第一个元素的值。 此方法改变数组的长度！</p>
<p>unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。    该方法将改变数组的数目。</p>
<h3 id="26、创建函数的三种方式"><a href="#26、创建函数的三种方式" class="headerlink" title="26、创建函数的三种方式"></a>26、创建函数的三种方式</h3><p>1.字面量的方式</p>
<p>function(){</p>
<p>}</p>
<p>2.函数表达式</p>
<p>var  say = function(){</p>
<p>}</p>
<p>3.对象的形式</p>
<p>var fun = new  Function()</p>
<h3 id="27、dom的增删改查"><a href="#27、dom的增删改查" class="headerlink" title="27、dom的增删改查"></a>27、dom的增删改查</h3><p>createElement()</p>
<p>removeChild()</p>
<p>查询：</p>
<ul>
<li>doucment.getElementById</li>
<li>document.getElementsByTagName</li>
<li>document.getElementsByName</li>
<li>document.getElementsByClassName</li>
<li>document.querySelectorAll</li>
<li>document.querySelector</li>
</ul>
<h3 id="28、jq方法"><a href="#28、jq方法" class="headerlink" title="28、jq方法"></a>28、jq方法</h3><h4 id="1-jQuery插入元素的方法"><a href="#1-jQuery插入元素的方法" class="headerlink" title="1.jQuery插入元素的方法:"></a>1.jQuery插入元素的方法:</h4><p>　　append(): 向每个匹配的元素内部追加内容.</p>
<p>　　appendTo(): 将所有匹配的元素追加到指定的元素中,即$(A).appendTo(B),是将A追加到B中.</p>
<p>　　prepend(): 向每个匹配的元素内部前置内容.</p>
<p>　　prependTo(): 将所有匹配的元素前置到指定的元素中,即$(A).prependTo(B),是将A前置到B中.</p>
<p>　　前面几个方法都是插入子元素,后面的这几个方法是插入兄弟元素.</p>
<p>　　after(): 在每个匹配的元素之后插入内容.</p>
<p>　　insertAfter(): 将所有匹配的元素插入到指定元素的后面.</p>
<p>　　before(): 在每个匹配的元素之前插入内容.</p>
<p>　　insertBefore(): 将所有匹配的元素插入到指定元素的前面.</p>
<p>　　jQuery支持方法链式的调用,即append()等方法返回的仍然是这个jQuery对象,后面可以继续调用append()方法.</p>
<h4 id="2-jQuery中删除节点的方法"><a href="#2-jQuery中删除节点的方法" class="headerlink" title="2.jQuery中删除节点的方法:"></a>2.jQuery中删除节点的方法:</h4><p>　　remove(): 移除所有匹配的元素.</p>
<p>　　empty(): 删除匹配的元素集合中所有内容,包括子节点.注意,元素本身没有被删除.</p>
<p>　　关于remove()方法,有几点需要说明一下:</p>
<p>　　1.remove()方法的返回值:</p>
<p>　　remove()方法会返回被删除节点的jQuery对象.可以把这个对象插入到其他的地方.</p>
<p>　　所以也可以用这种方法来移动节点:</p>
<h4 id="3-jQuery中复制节点的方法"><a href="#3-jQuery中复制节点的方法" class="headerlink" title="3.jQuery中复制节点的方法:"></a>3.jQuery中复制节点的方法:</h4><p>　　clone(): 创建匹配元素集合的副本.</p>
<p>　　clone()方法返回被复制的节点.</p>
<p>　　看一个例子,每次点击<li>都复制同样的元素并添加在<ul>末尾:</ul></li></p>
<h4 id="4-jQuery中替换节点的方法"><a href="#4-jQuery中替换节点的方法" class="headerlink" title="4.jQuery中替换节点的方法:"></a>4.jQuery中替换节点的方法:</h4><p>　　replaceAll(): 用指定的HTML内容或元素替换被选元素.</p>
<p>　　语法: $(content).replaceAll(selector).</p>
<p>　　replaceWith(): 用新内容替换所匹配到的元素.</p>
<p>　　语法: $(selector).replaceWith(content).</p>
<p>　　其中的content可以是HTML代码,可以是新元素,也可以是已经存在的元素.</p>
<p>　　关于用已有元素替换:</p>
<p>　　w3school的相关文档(<a href="http://www.w3school.com.cn/jquery/manipulation_replaceall.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jquery/manipulation_replaceall.asp</a>)中说:</p>
<p>　　“已经存在的元素不会被移动,只会被复制.”这种说法是不正确的.</p>
<p>　　实际做了实验之后,发现<strong>用已有元素替换,原来的元素是会被移除的</strong>:</p>
<h4 id="5-包裹节点"><a href="#5-包裹节点" class="headerlink" title="5.包裹节点,"></a>5.包裹节点,</h4><p>意思是把匹配的元素用指定的内容或者元素包裹起来,即增加一个父元素.</p>
<p>　　方法有:</p>
<p>　　wrap(): 把匹配的元素用指定的内容或元素包裹起来.</p>
<p>　　wrapAll(): 把所有匹配的元素用指定的内容或元素包裹起来,这里会将所有匹配的元素移动到一起,合成一组,只包裹一个parent.</p>
<p>　　wrapInner(): 将每一个匹配元素的内容用指定的内容或元素包裹起来.</p>
<p> 6.</p>
<p>JavaScript操纵DOM元素的方法和jQuery的相关方法名称区别如下:</p>
<p>　　JavaScript: appendChild(), removeChild().</p>
<p>　　jQuery: append(), remove(). 不过这个remove()移除的是自身.</p>
<h3 id="29、css中的不可继承属性"><a href="#29、css中的不可继承属性" class="headerlink" title="29、css中的不可继承属性"></a>29、css中的不可继承属性</h3><p>display  margin border padding  background  height  width position</p>
<h3 id="30、原生dom的操作"><a href="#30、原生dom的操作" class="headerlink" title="30、原生dom的操作"></a>30、原生dom的操作</h3><h4 id="1-0DOM操作增删改查"><a href="#1-0DOM操作增删改查" class="headerlink" title="1.0DOM操作增删改查"></a>1.0DOM操作增删改查</h4><h5 id="1-1-查询"><a href="#1-1-查询" class="headerlink" title="1.1. 查询"></a>1.1. 查询</h5><p>就是获取元素</p>
<ol>
<li>标准 DOM API<ul>
<li>doucment.getElementById</li>
<li>document.getElementsByTagName</li>
<li>document.getElementsByName</li>
<li>document.getElementsByClassName</li>
<li>document.querySelectorAll</li>
</ul>
</li>
<li>亲属访问</li>
<li>属性获取<ul>
<li>getAttribute</li>
<li>getAttributeNode</li>
</ul>
</li>
</ol>
<h5 id="1-2-增加"><a href="#1-2-增加" class="headerlink" title="1.2. 增加"></a>1.2. 增加</h5><ol>
<li><p>创建</p>
<ul>
<li>document.createEelement 创建元素节点</li>
<li>document.createTextNode 创建文本节点</li>
<li>doucment.createAttribute 属性节点</li>
<li>innerHTML</li>
<li>innerText</li>
<li>cloneNode()  </li>
</ul>
</li>
<li><p>加入</p>
<ul>
<li><p>appendChild 追加到结尾处</p>
</li>
<li><p>innerHTML</p>
</li>
<li><p>insertBefore 用法?将元素插入到某一个元素的前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父元素.insertBefore( 新元素, 旧元素 );</span><br><span class="line">// 将 新元素 插入到 旧元素 的前面</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>style 的操作</li>
<li>setAttribute( 属性名, 属性值 )</li>
</ul>
</li>
</ol>
<h5 id="1-3-删除"><a href="#1-3-删除" class="headerlink" title="1.3. 删除"></a>1.3. 删除</h5><ol>
<li>删除元素<ul>
<li>removeChild</li>
<li>removeAttributeNode</li>
</ul>
</li>
</ol>
<h5 id="1-4-修改"><a href="#1-4-修改" class="headerlink" title="1.4 修改"></a>1.4 修改</h5><ol>
<li>修改节点<ul>
<li>删除节点再加入</li>
</ul>
</li>
<li>修改样式<ul>
<li>style.xxx = vvv;</li>
<li>setAttribute</li>
</ul>
</li>
<li>修改文本<ul>
<li>innerHTML</li>
<li>innerText</li>
<li>节点操作</li>
<li>nodeValue</li>
</ul>
</li>
<li>修改属性<ul>
<li>.xxx = vvv</li>
<li>setAttribute修改属性</li>
<li>replaceChild()    </li>
</ul>
</li>
</ol>
<h4 id="2-0、对于不同DOM节点的操作总结"><a href="#2-0、对于不同DOM节点的操作总结" class="headerlink" title="2.0、对于不同DOM节点的操作总结"></a>2.0、对于不同DOM节点的操作总结</h4><p>​    虽然上面也全面的总结了相关的操作，但其实在查询使用时我更喜欢根据节点的NodeType来操作，因此对于属性节点和元素节点的常见操作分别归纳了一下</p>
<h5 id="2-1元素节点"><a href="#2-1元素节点" class="headerlink" title="2.1元素节点"></a>2.1元素节点</h5><p>2.1.1  添加 （先创建再添加）</p>
<p>　　创建</p>
<p>   　　  document.createEelement()    创建元素节点</p>
<p>​     　　当然使用 innerHTML，cloneChild的方法也能实现创建元素的目的</p>
<p> 　　 加入</p>
<ul>
<li>appendChild    追加到结尾处</li>
<li>innerHTML</li>
<li>insertBefore   </li>
</ul>
<p>2.1.2  删除元素</p>
<p>　　最常用得当然是removeChild （） ;</p>
<p>​      关于删除子元素：</p>
<p>　　　　 // 从 node 中删除 一个 div<br> 　　　　　　node.removeChild( divDOM );<br>　  　　 // 假设 node 节点中只有一个元素 div<br>　　　　　　 node.innerHTML = ‘’;</p>
<p>2.1.3修改节点 一般都是删除再加入，即removeChild+appendChild，也可以使用replaceChild() 直接替换</p>
<p>先总结这些，其实DOM的方法虽然多，但好在常用的很少见，希望大家可以在理解DOM结构的基础上熟练操作DOM的apl。</p>
<h4 id="3-0-元素节点"><a href="#3-0-元素节点" class="headerlink" title="3.0 元素节点"></a>3.0 元素节点</h4><p> 3.2.1 添加属性    </p>
<p>​    doucment.createAttribute()  创建属性节点</p>
<p>​    使用 setAttribute 添加属性<br>        // 添加自定义, 非标准的属性 ( DOM-Core ) </p>
<p>　　　　div.setAttribute( ‘attrName’, ‘attrValue’ );<br>    使用 .xxx = vvv利用对象的动态特性添加属性<br>        // 添加的标准属性( HTML-DOM )<br>                div.attrName = ‘attrValue’;<br>    第三种( 了解 )使用 DOM 节点方法<br>        // 纯 DOM-Core 的做法<br>                var attrNode = document.createAttribute( ‘test’ );//创建属性节点对象<br>                attr.nodeValue = ‘测试’;  //设置属性值<br>                div.setAttributeNode( attrNode );   //添加给div<br>    区别<br>        div.setAttributeNode(attrnode对象）<br>        div.setAttribute（’属性名’，’属性值‘）；</p>
<p>3.2.2 删除<br>        removeAttribute（’属性名’）<br>        removeArrtibuteNode（节点对象名）</p>
<p>　　　　//removeAttribute 是 为了 简化node.removeAttribute( ‘属性名’ ),不用先获取属性节点再删除，而是直接操作元素节点;</p>
<p>3.33   获取<br>    getAttribute(‘属性名 ‘)  获取属性值  //简化了node.getAttributeNode( ‘属性名’ );</p>
<p>​    getAttributeNode（’属性名’）  获取属性节点对象   </p>
<p>  // var attrNode = node.getAttributeNode( ‘属性名’ );<br>  // attrNode.nodeValue;</p>
<h3 id="31、js中字符串的操作方法"><a href="#31、js中字符串的操作方法" class="headerlink" title="31、js中字符串的操作方法"></a>31、js中字符串的操作方法</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>1.charAt 返回指定索引处的字符<br>    var str=’abcd’;<br>　var a=str.charAt(0);<br>　console.log(a); //‘a’<br>    console.log(str); //‘abcd’<br>2.charCodeAt 返回指定索引出的unicode字符</p>
<p>　str.charCodeAt(0);   //97</p>
<p>3.indexof  判断一个字符第一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1.</p>
<p>　str.indexOf(‘a’);     //0<br>　 str.indexOf(‘e’);     //-1</p>
<p>4.lastIndexOf 判断一个字符最后一次出现在某个字符串的索引，如果包含返回它的索引，如果不包含返回-1.</p>
<p>　str.lastIndexOf(‘b’);   //1<br>     str.lastIndexOf(‘e’);   //-1<br>5.concat拼接2个字符串，返回一个新字符串，对原有字符串没有任何改变。</p>
<p>​    var str=’qwe’;<br>    var str1=’abc’;<br>    var str2=str.concat(str1);</p>
<p>​    console.log(str2);//“qweabc”</p>
<p>6.substr(n,m) 从索引n开始，截取m个字符，将截取的字符返回，对原字符串没有任何改变。<br>　　var b=s.substr(1,1)<br>       console.log(b);  //‘w’</p>
<p>7.substring(n,m)   从索引n开始，截取到索引m,不包括m.将截取的字符返回,对原字符串没有任何改变.</p>
<p>　　var ee=str.substring(1,3);<br>　　console.log(ee);  //“bc”</p>
<p>8.slice(n,m)   从索引n开始，截取到索引m,不包括m.将截取的字符返回,对原字符串没有任何改变.<br>　var aa=str.slice(0,3);<br>　 console.log（aa）;//‘abc’</p>
<p>9.split  用指定字符分割字符串，返回一个数组.对原字符串没有任何改变。</p>
<p>　　var a=str.split(‘’);<br>      console.log(a);  //[“a”, “b”, “c”, “d”]</p>
<p>10.replace(‘a’,1);  替换指定字符，返回替换后新的字符串，对原有字符串有改变。(第一个参数可以是正则表达式) 只能替换一次 ，配合正则模式修饰符g使用<br>　　var str=’aaaaee’;<br>　　var reg=/a/g;<br>　　str.replace(reg,1);   //“1111ee”<br>11.match() 可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把找到的字符放在数组里，返回一个数组。</p>
<p>　　var str=’aaaa3ed33’;<br>　　var reg=/a/g;<br>　　str.match(reg);  //[“a”, “a”, “a”, “a”]</p>
<p>12.search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。</p>
<h4 id="es6新增加的方法"><a href="#es6新增加的方法" class="headerlink" title="es6新增加的方法"></a>es6新增加的方法</h4><p>1.codePointAt()  能够正确处理4个字节储存的字符，返回指定索引出一个字符的码点。codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<p><code>var s = &#39;𠮷a&#39;;</code></p>
<p><code>s.codePointAt(0) // 134071</code></p>
<p><code>s.codePointAt(1) // 57271</code></p>
<p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;𠮷a&apos;;</span><br><span class="line">s.codePointAt(0).toString(16) // &quot;20bb7&quot;</span><br><span class="line">s.codePointAt(2).toString(16) // &quot;61&quot;不能识别32位的UTF-16字符</span><br></pre></td></tr></table></figure>
<p>配合<code>for...of</code>循环使用，因为它会正确识别32位的UTF-16字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;𠮷a&apos;;</span><br><span class="line">for (let ch of s) &#123;</span><br><span class="line">  console.log(ch.codePointAt(0).toString(16));</span><br><span class="line">&#125;</span><br><span class="line">// 20bb7</span><br><span class="line">// 61</span><br></pre></td></tr></table></figure>
<p>2.codePointAt用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于<code>0xFFFF</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(0x20BB7)</span><br><span class="line">// &quot;𠮷&quot;</span><br><span class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>3.for..of  字符串的遍历器接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let codePoint of &apos;foo&apos;) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// &quot;f&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">// &quot;o&quot;</span><br></pre></td></tr></table></figure>
<p>4.at()  返回指定索引处的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.at(0) // &quot;a&quot;</span><br><span class="line">&apos;𠮷&apos;.at(0) // &quot;𠮷&quot;</span><br></pre></td></tr></table></figure>
<p>5.<strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<p>6.<strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<p>7.<strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;world&apos;, 6) // true</span><br><span class="line">s.endsWith(&apos;Hello&apos;, 5) // true</span><br><span class="line">s.includes(&apos;Hello&apos;, 6) // false</span><br></pre></td></tr></table></figure>
<p><em>8.repeat()  方法返回一个新字符串，表示将原字符串重复n次。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br><span class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</span><br><span class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>9.padStart()，padEnd()字符串补全长度的功能</p>
<p>   padStart()用于头部补全</p>
<p>   padEnd()用于尾部补全</p>
<p><code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line"></span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;</span><br><span class="line">&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos;</span><br></pre></td></tr></table></figure>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)</span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(4) // &apos;   x&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4) // &apos;x   &apos;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/js高级/" rel="next" title="js高级">
                <i class="fa fa-chevron-left"></i> js高级
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/25/特殊名词/" rel="prev" title="特殊名词">
                特殊名词 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="ling">
            
              <p class="site-author-name" itemprop="name">ling</p>
              <p class="site-description motion-element" itemprop="description">little repository</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/yourname" title="Github &rarr; https://github.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:yourname@gmail.com" title="E-Mail &rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://plus.google.com/yourname" title="Google &rarr; https://plus.google.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/yourname" title="Twitter &rarr; https://twitter.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、总结前端习题"><span class="nav-number">1.</span> <span class="nav-text">1、总结前端习题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-原型对象与实例对象的区别："><span class="nav-number">1.0.1.</span> <span class="nav-text">1.原型对象与实例对象的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数据类型"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-嵌入html文档中的图像格式"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.嵌入html文档中的图像格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-判断类型"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.判断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-jQuery-ajax支持哪些数据类型"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.jQuery ajax支持哪些数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-正则表达式"><span class="nav-number">1.0.6.</span> <span class="nav-text">6.正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-CSS-的盒子模型有两种：IE-盒子模型、标准的-W3C-盒子模型模型"><span class="nav-number">1.0.7.</span> <span class="nav-text">7.CSS 的盒子模型有两种：IE 盒子模型、标准的 W3C 盒子模型模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-inline-block元素："><span class="nav-number">1.0.8.</span> <span class="nav-text">8.inline-block元素：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-无效值或空值："><span class="nav-number">1.0.9.</span> <span class="nav-text">9.无效值或空值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-空元素"><span class="nav-number">1.0.10.</span> <span class="nav-text">10.空元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、ajax"><span class="nav-number">1.0.11.</span> <span class="nav-text">11、ajax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、ECMAScript包括两个不同类型的值："><span class="nav-number">1.0.12.</span> <span class="nav-text">12、ECMAScript包括两个不同类型的值：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、常见的基本数据类型："><span class="nav-number">1.0.12.1.</span> <span class="nav-text">1、常见的基本数据类型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、引用类型数据："><span class="nav-number">1.0.12.2.</span> <span class="nav-text">2、引用类型数据：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、hasOwnProperty方法"><span class="nav-number">1.0.13.</span> <span class="nav-text">13、hasOwnProperty方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、slice"><span class="nav-number">1.0.14.</span> <span class="nav-text">14、slice()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、静态成员和实例成员的区别"><span class="nav-number">1.0.15.</span> <span class="nav-text">15、静态成员和实例成员的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-js中的方法"><span class="nav-number">1.0.16.</span> <span class="nav-text">16.js中的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-charAt"><span class="nav-number">1.0.16.1.</span> <span class="nav-text">1.charAt()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-join"><span class="nav-number">1.0.16.2.</span> <span class="nav-text">2.join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-split"><span class="nav-number">1.0.16.3.</span> <span class="nav-text">3.split()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、splice"><span class="nav-number">1.0.16.4.</span> <span class="nav-text">4、splice()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、concat"><span class="nav-number">1.0.16.5.</span> <span class="nav-text">5、concat()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、substring"><span class="nav-number">1.0.16.6.</span> <span class="nav-text">6、substring()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、"><span class="nav-number">1.0.16.7.</span> <span class="nav-text">7、</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、IE流和DOM流的区别"><span class="nav-number">1.0.17.</span> <span class="nav-text">17、IE流和DOM流的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、random"><span class="nav-number">1.0.18.</span> <span class="nav-text">18、random()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、document-forms-length和document-forms-elements-length的区别"><span class="nav-number">1.0.19.</span> <span class="nav-text">19、document.forms.length和document.forms.elements.length的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、JavaScript-有一些保留字，不能用作标识符："><span class="nav-number">1.0.20.</span> <span class="nav-text">20、JavaScript 有一些保留字，不能用作标识符：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、判断类型"><span class="nav-number">1.0.21.</span> <span class="nav-text">21、判断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、BOM浏览器对象模型"><span class="nav-number">1.0.22.</span> <span class="nav-text">22、BOM浏览器对象模型</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#2、面试题"><span class="nav-number">2.</span> <span class="nav-text">2、面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、apply、call、bind的区别"><span class="nav-number">2.1.</span> <span class="nav-text">1、apply、call、bind的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-apply-例子："><span class="nav-number">2.1.0.1.</span> <span class="nav-text">(1)apply 例子：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-call-例子："><span class="nav-number">2.1.0.2.</span> <span class="nav-text">(2)call 例子：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-bind-例子："><span class="nav-number">2.1.0.3.</span> <span class="nav-text">(3)bind 例子：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、闭包（closure）"><span class="nav-number">2.2.</span> <span class="nav-text">2、闭包（closure）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、要理解闭包，首先必须理解Javascript特殊的变量作用域。"><span class="nav-number">2.2.1.</span> <span class="nav-text">一、要理解闭包，首先必须理解Javascript特殊的变量作用域。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、如何从外部读取局部变量？"><span class="nav-number">2.2.2.</span> <span class="nav-text">二、如何从外部读取局部变量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、闭包"><span class="nav-number">2.2.3.</span> <span class="nav-text">三、闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、深拷贝、浅拷贝"><span class="nav-number">2.3.</span> <span class="nav-text">3、深拷贝、浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝和浅拷贝的区别"><span class="nav-number">2.3.1.</span> <span class="nav-text">深拷贝和浅拷贝的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-堆（stack）和栈（heap）"><span class="nav-number">2.3.2.</span> <span class="nav-text">1.堆（stack）和栈（heap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-值与引用"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.值与引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-深拷贝和浅拷贝"><span class="nav-number">2.3.4.</span> <span class="nav-text">3.深拷贝和浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）浅拷贝："><span class="nav-number">2.3.4.1.</span> <span class="nav-text">（1）浅拷贝：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）深拷贝"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">（2）深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-gt-实现深拷贝，这里可以递归递归去复制所有层级属性。"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">1 &gt;   实现深拷贝，这里可以递归递归去复制所有层级属性。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-gt-还可以借用JSON对象的parse和stringify"><span class="nav-number">2.3.4.2.2.</span> <span class="nav-text">2&gt;   还可以借用JSON对象的parse和stringify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-gt-还可以借用JQ的extend方法。"><span class="nav-number">2.3.4.2.3.</span> <span class="nav-text">3&gt;    还可以借用JQ的extend方法。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4，es6语法："><span class="nav-number">2.4.</span> <span class="nav-text">4，es6语法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、原型链"><span class="nav-number">2.5.</span> <span class="nav-text">5、原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、一个数组如何排序"><span class="nav-number">2.6.</span> <span class="nav-text">6、一个数组如何排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7解构"><span class="nav-number">2.7.</span> <span class="nav-text">7解构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-对象解构（解构源）"><span class="nav-number">2.7.1.</span> <span class="nav-text">(1)对象解构（解构源）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-解构数组"><span class="nav-number">2.7.2.</span> <span class="nav-text">(2)解构数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-解构赋值"><span class="nav-number">2.7.3.</span> <span class="nav-text">(3)解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-解构带上默认值"><span class="nav-number">2.7.4.</span> <span class="nav-text">(4)解构带上默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-多参数：-…操作符"><span class="nav-number">2.7.5.</span> <span class="nav-text">(5)多参数： …操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-交换"><span class="nav-number">2.7.6.</span> <span class="nav-text">(6)交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构在函数中的好处"><span class="nav-number">2.7.7.</span> <span class="nav-text">解构在函数中的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构不好的地方"><span class="nav-number">2.7.8.</span> <span class="nav-text">解构不好的地方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8继承"><span class="nav-number">2.8.</span> <span class="nav-text">8继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、实现跨域的几种方式"><span class="nav-number">2.9.</span> <span class="nav-text">9、实现跨域的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、使用-lt-script-src-””-gt-来完成一个跨域请求："><span class="nav-number">2.9.1.</span> <span class="nav-text">1、使用 &lt;  script src=”” &gt;来完成一个跨域请求：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、再来看jquery的jsonp方式跨域请求："><span class="nav-number">2.9.2.</span> <span class="nav-text">2、再来看jquery的jsonp方式跨域请求：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、cors解决跨域"><span class="nav-number">2.9.3.</span> <span class="nav-text">3、cors解决跨域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结："><span class="nav-number">2.9.4.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、浮动及清除浮动的几种方式？"><span class="nav-number">2.10.</span> <span class="nav-text">10、浮动及清除浮动的几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、cookie-sessionStorage-localStorage的区别"><span class="nav-number">2.11.</span> <span class="nav-text">11、cookie,sessionStorage,localStorage的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、cookie和session"><span class="nav-number">2.11.1.</span> <span class="nav-text">一、cookie和session</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、继承的几种方式"><span class="nav-number">2.12.</span> <span class="nav-text">12、继承的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、rem、em、px的区别"><span class="nav-number">2.13.</span> <span class="nav-text">13、rem、em、px的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#px："><span class="nav-number">2.13.1.</span> <span class="nav-text">px：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#em："><span class="nav-number">2.13.2.</span> <span class="nav-text">em：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rem："><span class="nav-number">2.13.3.</span> <span class="nav-text">rem：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注意："><span class="nav-number">2.13.3.1.</span> <span class="nav-text">注意：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、举例IE的兼容性问题（ie常见bug）"><span class="nav-number">2.14.</span> <span class="nav-text">14、举例IE的兼容性问题（ie常见bug）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、jq中链式编程"><span class="nav-number">2.15.</span> <span class="nav-text">15、jq中链式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式编程"><span class="nav-number">3.</span> <span class="nav-text">链式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16、双倍边距"><span class="nav-number">3.1.</span> <span class="nav-text">16、双倍边距</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、手写数组去重，冒泡排序"><span class="nav-number">3.2.</span> <span class="nav-text">17、手写数组去重，冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、ajax用js的实现"><span class="nav-number">3.3.</span> <span class="nav-text">18、ajax用js的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、状态码"><span class="nav-number">3.4.</span> <span class="nav-text">19、状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、http的请求方式"><span class="nav-number">3.5.</span> <span class="nav-text">20、http的请求方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、H5C3新特性"><span class="nav-number">3.6.</span> <span class="nav-text">21、H5C3新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、页面优化的方式"><span class="nav-number">3.7.</span> <span class="nav-text">22、页面优化的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、减少HTTP请求"><span class="nav-number">3.7.1.</span> <span class="nav-text">一、减少HTTP请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、使用CDN"><span class="nav-number">3.7.2.</span> <span class="nav-text">二、使用CDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、添加Expires头（Expires：协议）"><span class="nav-number">3.7.3.</span> <span class="nav-text">三、添加Expires头（Expires：协议）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、压缩组件"><span class="nav-number">3.7.4.</span> <span class="nav-text">四、压缩组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、将样式表放在头部"><span class="nav-number">3.7.5.</span> <span class="nav-text">五、将样式表放在头部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、将脚本放在底部"><span class="nav-number">3.7.6.</span> <span class="nav-text">六、将脚本放在底部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、避免CSS表达式"><span class="nav-number">3.7.7.</span> <span class="nav-text">七、避免CSS表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、使用外部的JavaScript和CSS"><span class="nav-number">3.7.8.</span> <span class="nav-text">八、使用外部的JavaScript和CSS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九、减少DNS查找"><span class="nav-number">3.7.9.</span> <span class="nav-text">九、减少DNS查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十、精简JavaScript"><span class="nav-number">3.7.10.</span> <span class="nav-text">十、精简JavaScript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十一、避免重定向"><span class="nav-number">3.7.11.</span> <span class="nav-text">十一、避免重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十二、删除重复脚本"><span class="nav-number">3.7.12.</span> <span class="nav-text">十二、删除重复脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十三、使Ajax可缓存"><span class="nav-number">3.7.13.</span> <span class="nav-text">十三、使Ajax可缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十四、加载后下载"><span class="nav-number">3.7.14.</span> <span class="nav-text">十四、加载后下载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23、css优化提高性能的方法"><span class="nav-number">3.8.</span> <span class="nav-text">23、css优化提高性能的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24、vue相关知识点（开发中遇到的问题）"><span class="nav-number">3.9.</span> <span class="nav-text">24、vue相关知识点（开发中遇到的问题）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25、数组的几种操作方式"><span class="nav-number">3.10.</span> <span class="nav-text">25、数组的几种操作方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26、创建函数的三种方式"><span class="nav-number">3.11.</span> <span class="nav-text">26、创建函数的三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27、dom的增删改查"><span class="nav-number">3.12.</span> <span class="nav-text">27、dom的增删改查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28、jq方法"><span class="nav-number">3.13.</span> <span class="nav-text">28、jq方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-jQuery插入元素的方法"><span class="nav-number">3.13.1.</span> <span class="nav-text">1.jQuery插入元素的方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-jQuery中删除节点的方法"><span class="nav-number">3.13.2.</span> <span class="nav-text">2.jQuery中删除节点的方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-jQuery中复制节点的方法"><span class="nav-number">3.13.3.</span> <span class="nav-text">3.jQuery中复制节点的方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-jQuery中替换节点的方法"><span class="nav-number">3.13.4.</span> <span class="nav-text">4.jQuery中替换节点的方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-包裹节点"><span class="nav-number">3.13.5.</span> <span class="nav-text">5.包裹节点,</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29、css中的不可继承属性"><span class="nav-number">3.14.</span> <span class="nav-text">29、css中的不可继承属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30、原生dom的操作"><span class="nav-number">3.15.</span> <span class="nav-text">30、原生dom的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-0DOM操作增删改查"><span class="nav-number">3.15.1.</span> <span class="nav-text">1.0DOM操作增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-查询"><span class="nav-number">3.15.1.1.</span> <span class="nav-text">1.1. 查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-增加"><span class="nav-number">3.15.1.2.</span> <span class="nav-text">1.2. 增加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-删除"><span class="nav-number">3.15.1.3.</span> <span class="nav-text">1.3. 删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-修改"><span class="nav-number">3.15.1.4.</span> <span class="nav-text">1.4 修改</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-0、对于不同DOM节点的操作总结"><span class="nav-number">3.15.2.</span> <span class="nav-text">2.0、对于不同DOM节点的操作总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1元素节点"><span class="nav-number">3.15.2.1.</span> <span class="nav-text">2.1元素节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-0-元素节点"><span class="nav-number">3.15.3.</span> <span class="nav-text">3.0 元素节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31、js中字符串的操作方法"><span class="nav-number">3.16.</span> <span class="nav-text">31、js中字符串的操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">3.16.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#es6新增加的方法"><span class="nav-number">3.16.2.</span> <span class="nav-text">es6新增加的方法</span></a></li></ol></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ling</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.7.0</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  


  





  

  

  

  

  

  

  

  

  

  

  

  

  

<script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
